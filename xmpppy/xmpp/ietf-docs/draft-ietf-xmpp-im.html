<html><head><title>Extensible Messaging and Presence Protocol (XMPP): Instant Messaging and Presence</title>
<STYLE type='text/css'>
    .title { color: #990000; font-size: 22px; line-height: 22px; font-weight: bold; text-align: right;
             font-family: helvetica, arial, sans-serif }
    .filename { color: #666666; font-size: 18px; line-height: 28px; font-weight: bold; text-align: right;
                  font-family: helvetica, arial, sans-serif }
    p.copyright { color: #000000; font-size: 10px;
                  font-family: verdana, charcoal, helvetica, arial, sans-serif }
    p { margin-left: 2em; margin-right: 2em; }
    span.emph { font-style: italic; }
    span.strong { font-weight: bold; }
    span.verb { font-style: oblique; }
    li { margin-left: 3em;  }
    ol { margin-left: 2em; margin-right: 2em; }
    ul.text { margin-left: 2em; margin-right: 2em; }
    pre { margin-left: 3em; color: #333333 }
    ul.toc { color: #000000; line-height: 16px;
             font-family: verdana, charcoal, helvetica, arial, sans-serif }
    H3 { color: #333333; font-size: 16px; line-height: 16px; font-family: helvetica, arial, sans-serif }
    H4 { color: #000000; font-size: 14px; font-family: helvetica, arial, sans-serif }
    TD.header { color: #ffffff; font-size: 10px; font-family: arial, helvetica, san-serif; valign: top }
    TD.author-text { color: #000000; font-size: 10px;
                     font-family: verdana, charcoal, helvetica, arial, sans-serif }
    TD.author { color: #000000; font-weight: bold; margin-left: 4em; font-size: 10px; font-family: verdana, charcoal, helvetica, arial, sans-serif }
     A:link { color: #990000; font-weight: bold;
              font-family: MS Sans Serif, verdana, charcoal, helvetica, arial, sans-serif }
     A:visited { color: #333333; font-weight: bold;
                 font-family: MS Sans Serif, verdana, charcoal, helvetica, arial, sans-serif }
     A:name { color: #333333; font-weight: bold;
              font-family: MS Sans Serif, verdana, charcoal, helvetica, arial, sans-serif }
    .link2 { color:#ffffff; font-weight: bold; text-decoration: none;
             font-family: monaco, charcoal, geneva, MS Sans Serif, helvetica, monotype, verdana, sans-serif;
             font-size: 9px }
    .RFC { color:#666666; font-weight: bold; text-decoration: none;
           font-family: monaco, charcoal, geneva, MS Sans Serif, helvetica, monotype, verdana, sans-serif;
           font-size: 9px }
    .hotText { color:#ffffff; font-weight: normal; text-decoration: none;
               font-family: charcoal, monaco, geneva, MS Sans Serif, helvetica, monotype, verdana, sans-serif;
               font-size: 9px }
</style>
</head>
<body bgcolor="#ffffff" text="#000000" alink="#000000" vlink="#666666" link="#990000">
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<table width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table width="100%" border="0" cellpadding="2" cellspacing="1">
<tr valign="top"><td width="33%" bgcolor="#666666" class="header">XMPP Working Group</td><td width="33%" bgcolor="#666666" class="header">P. Saint-Andre (ed.)</td></tr>
<tr valign="top"><td width="33%" bgcolor="#666666" class="header">Internet-Draft</td><td width="33%" bgcolor="#666666" class="header">Jabber Software Foundation</td></tr>
<tr valign="top"><td width="33%" bgcolor="#666666" class="header">Expires: May 20, 2004</td><td width="33%" bgcolor="#666666" class="header">November 20, 2003</td></tr>
</table></td></tr></table>
<div align="right"><font face="monaco, MS Sans Serif" color="#990000" size="+3"><b><br><span class="title">Extensible Messaging and Presence Protocol (XMPP): Instant Messaging and Presence</span></b></font></div>
<div align="right"><font face="monaco, MS Sans Serif" color="#666666" size="+2"><b><span class="filename">draft-ietf-xmpp-im-19</span></b></font></div>
<font face="verdana, helvetica, arial, sans-serif" size="2">

<h3>Status of this Memo</h3>
<p>
This document is an Internet-Draft and is in full conformance with all provisions of Section 10 of RFC2026.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as "work in progress."</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on May 20, 2004.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (C) The Internet Society (2003). All Rights Reserved.</p>

<h3>Abstract</h3>

<p>This memo describes extensions to and applications of the core features of the Extensible Messaging and Presence Protocol (XMPP) that provide the basic instant messaging (IM) and presence functionality defined in RFC 2779.
</p><a name="toc"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<h3>Table of Contents</h3>
<ul compact class="toc">
<b><a href="#intro">1.</a>&nbsp;
Introduction<br></b>
<b><a href="#stanzas">2.</a>&nbsp;
Syntax of XML Stanzas<br></b>
<b><a href="#session">3.</a>&nbsp;
Session Establishment<br></b>
<b><a href="#messaging">4.</a>&nbsp;
Exchanging Messages<br></b>
<b><a href="#presence">5.</a>&nbsp;
Exchanging Presence Information<br></b>
<b><a href="#sub">6.</a>&nbsp;
Managing Subscriptions<br></b>
<b><a href="#roster">7.</a>&nbsp;
Roster Management<br></b>
<b><a href="#int">8.</a>&nbsp;
Integration of Roster Items and Presence Subscriptions<br></b>
<b><a href="#substates">9.</a>&nbsp;
Subscription States<br></b>
<b><a href="#privacy">10.</a>&nbsp;
Blocking Communication<br></b>
<b><a href="#rules">11.</a>&nbsp;
Server Rules for Handling XML Stanzas<br></b>
<b><a href="#compliance">12.</a>&nbsp;
IM and Presence Compliance Requirements<br></b>
<b><a href="#i18n">13.</a>&nbsp;
Internationalization Considerations<br></b>
<b><a href="#security">14.</a>&nbsp;
Security Considerations<br></b>
<b><a href="#ref">15.</a>&nbsp;
IANA Considerations<br></b>
<b><a href="#rfc.references1">&#167;</a>&nbsp;
Normative References<br></b>
<b><a href="#rfc.references2">&#167;</a>&nbsp;
Informative References<br></b>
<b><a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br></b>
<b><a href="#vcard">A.</a>&nbsp;
vCards<br></b>
<b><a href="#def">B.</a>&nbsp;
XML Schemas<br></b>
<b><a href="#diffs">C.</a>&nbsp;
Differences Between Jabber IM/Presence and XMPP<br></b>
<b><a href="#rev">D.</a>&nbsp;
Revision History<br></b>
<b><a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br></b>
</ul>
<br clear="all">

<a name="intro"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;Introduction</h3>

<a name="rfc.section.1.1"></a><h4><a name="intro-overview">1.1</a>&nbsp;Overview</h4>

<p>The Extensible Messaging and Presence Protocol (XMPP) is a protocol for streaming <a href="#XML" title="Bray, T., Paoli, J., Sperberg-McQueen, C. and E. Maler, Extensible Markup Language (XML) 1.0 (2nd ed), October 2000.">XML</a>[XML] elements in order to exchange messages and presence information in close to real time.  The core features of XMPP are defined in <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">Extensible Messaging and Presence Protocol (XMPP): Core</a>[XMPP-CORE].  These features -- mainly XML streams, use of TLS and SASL, and the &lt;message/&gt;, &lt;presence/&gt;, and &lt;iq/&gt; children of the stream root -- provide the building blocks for many types of near-real-time applications, which may be layered on top of the core by sending application-specific data qualified by particular <a href="#XML-NAMES" title="Bray, T., Hollander, D. and A. Layman, Namespaces in XML, January 1999.">XML namespaces</a>[XML-NAMES].  This memo describes extensions to and applications of the core features of XMPP that provide the basic functionality expected of an instant messaging (IM) and presence application as defined in <a href="#IMP-REQS" title="Day, M., Aggarwal, S. and J. Vincent, Instant Messaging / Presence Protocol Requirements, February 2000.">RFC 2779</a>[IMP-REQS].
</p>
<a name="rfc.section.1.2"></a><h4><a name="intro-requirements">1.2</a>&nbsp;Requirements</h4>

<p>For the purposes of this memo, the requirements of a basic instant messaging and presence application are defined by <a href="#IMP-REQS" title="Day, M., Aggarwal, S. and J. Vincent, Instant Messaging / Presence Protocol Requirements, February 2000.">[IMP-REQS]</a>, which at a high level stipulates that a user must be able to complete the following use cases:
</p>
<p>
<ul class="text">
<li>Exchange messages with other users
</li>
<li>Exchange presence information with other users
</li>
<li>Manage subscriptions to and from other users
</li>
<li>Manage items in a contact list (in XMPP this is called a "roster")
</li>
<li>Block communications to or from specific other users
</li>
</ul><p>
</p>
<p>Detailed definitions of these functionality areas are contained in <a href="#IMP-REQS" title="Day, M., Aggarwal, S. and J. Vincent, Instant Messaging / Presence Protocol Requirements, February 2000.">[IMP-REQS]</a>, and the interested reader is directed to that document regarding the requirements addressed herein.
</p>
<p><a href="#IMP-REQS" title="Day, M., Aggarwal, S. and J. Vincent, Instant Messaging / Presence Protocol Requirements, February 2000.">[IMP-REQS]</a> also stipulates that presence services must be separable from instant messaging services; i.e., it must be possible to use the protocol to provide a presence service, an instant messaging service, or both.  Although the text of this memo assumes that implementations and deployments will want to offer a unified instant messaging and presence service, there is no requirement that a service must offer both a presence service and an instant messaging service, and the protocol makes it possible to offer separate and distinct services for presence and for instant messaging.
</p>
<p>Note: While XMPP-based instant messaging and presence meets the requirements of <a href="#IMP-REQS" title="Day, M., Aggarwal, S. and J. Vincent, Instant Messaging / Presence Protocol Requirements, February 2000.">[IMP-REQS]</a>, it was not designed explicitly with that specification in mind, since the base protocol evolved through an open development process within the Jabber open-source community before RFC 2779 was written.  Note also that although protocols addressing many other functionality areas have been defined in the Jabber community, such protocols are not included in this memo because they are not required by <a href="#IMP-REQS" title="Day, M., Aggarwal, S. and J. Vincent, Instant Messaging / Presence Protocol Requirements, February 2000.">[IMP-REQS]</a>.
</p>
<a name="rfc.section.1.3"></a><h4><a name="intro-terms">1.3</a>&nbsp;Terminology</h4>

<p>This memo inherits the terminology defined in <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a>.
</p>
<p>The capitalized key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#TERMS" title="Bradner, S., Key words for use in RFCs to Indicate Requirement Levels, March 1997.">RFC 2119</a>[TERMS].
</p>
<a name="rfc.section.1.4"></a><h4><a name="intro-discuss">1.4</a>&nbsp;Discussion Venue</h4>

<p>The authors welcome discussion and comments related to the topics presented in this document.  The preferred forum is the &lt;xmppwg@jabber.org&gt; mailing list, for which archives and subscription information are available at &lt;<a href="http://www.jabber.org/cgi-bin/mailman/listinfo/xmppwg/">http://www.jabber.org/cgi-bin/mailman/listinfo/xmppwg/</a>&gt;.
</p>
<a name="rfc.section.1.5"></a><h4><a name="intro-ipr">1.5</a>&nbsp;Intellectual Property Notice</h4>

<p>This document is in full compliance with all provisions of Section 10 of RFC 2026.  Parts of this specification use the term "jabber" for identifying namespaces and other protocol syntax.  Jabber[tm] is a registered trademark of Jabber, Inc.  Jabber, Inc. grants permission to the IETF for use of the Jabber trademark in association with this specification and its successors, if any.
</p>
<a name="rfc.section.1.6"></a><h4><a name="contributors">1.6</a>&nbsp;Contributors</h4>

<p>Most of the core aspects of the Extensible Messaging and Presence Protocol were developed originally within the Jabber open-source community in 1999.  This community was founded by Jeremie Miller, who released source code for the initial version of the jabberd server in January 1999.  Major early contributors to the base protocol also included Ryan Eatmon, Peter Millard, Thomas Muldowney, and Dave Smith. Work specific to instant messaging and presence by the XMPP Working Group has concentrated especially on IM session establishment and communication blocking (privacy rules); the session establishment protocol was mainly developed by Rob Norris and Joe Hildebrand, and the privacy rules protocol was originally contributed by Peter Millard.
</p>
<a name="rfc.section.1.7"></a><h4><a name="acknowledgements">1.7</a>&nbsp;Acknowledgements</h4>

<p>Thanks are due to a number of individuals in addition to the contributors listed.  Although it is difficult to provide a complete list, the following individuals were particularly helpful in defining the protocols or in commenting on the specifications in this memo: Thomas Charron, Richard Dobson, Schuyler Heath, Jonathan Hogg, Craig Kaes, Jacek Konieczny, Alexey Melnikov, Keith Minkler, Julian Missig, Pete Resnick, Marshall Rose, Alexey Shchepin, Jean-Louis Seguineau, Iain Shigeoka, and David Waite.  Thanks also to members of the XMPP Working Group and the IETF community for comments and feedback provided throughout the life of this memo.
</p>
<a name="stanzas"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;Syntax of XML Stanzas</h3>

<p>The basic semantics and common attributes of XML stanzas qualified by the 'jabber:client' and 'jabber:server' namespaces are defined in <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a>.  However, these namespaces also define various child elements, as well as values for the common 'type' attribute, that are specific to instant messaging and presence applications.  Thus, before addressing particular "use cases" for such applications, we here further describe the syntax of XML stanzas, thereby supplementing the discussion in <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a>.
</p>
<a name="rfc.section.2.1"></a><h4><a name="stanzas-message">2.1</a>&nbsp;Message Syntax</h4>

<p>Message stanzas in the 'jabber:client' or 'jabber:server' namespace are used to "push" information to another entity.  Common uses in instant messaging applications include single messages, messages sent in the context of a chat conversation, messages sent in the context of a multi-user chat room, headlines, and errors.
</p>
<a name="rfc.section.2.1.1"></a><h4><a name="stanzas-message-type">2.1.1</a>&nbsp;Types of Message</h4>

<p>The 'type' attribute of a message stanza is RECOMMENDED; if included, it specifies the conversational context of the message, thus providing a hint regarding presentation (e.g., in a GUI).  If included, the 'type' attribute MUST have one of the following values:
</p>
<p>
<ul class="text">
<li>chat -- The message is sent in the context of a one-to-one chat conversation.  A compliant client SHOULD present the message an interface enabling one-to-one chat between the two parties, including an appropriate conversation history.
</li>
<li>error -- An error has occurred related to a previous message sent by the sender (for details regarding stanza error syntax, refer to <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a>).  A compliant client SHOULD present an appropriate interface informing the sender of the nature of the error.
</li>
<li>groupchat -- The message is sent in the context of a multi-user chat environment.  A compliant client SHOULD present the message an interface enabling many-to-many chat between the parties, including a roster of parties in the chatroom and an appropriate conversation history.  Full definition of XMPP-based groupchat protocols is out of scope for this memo.
</li>
<li>headline -- The message is probably generated by an automated service that delivers or broadcasts content (news, sports, market information, RSS feeds, etc.).  No reply to the message is expected, and a compliant client SHOULD present the message an interface that appropriately differentiates the message from standalone messages, chat sessions, or groupchat sessions (e.g., by not providing the recipient with the ability to reply).
</li>
<li>normal -- The message is a single message that is sent outside the context of a one-to-one conversation or groupchat, and to which it is expected that the recipient will reply.  A compliant client SHOULD present the message in an interface enabling the recipient to reply.
</li>
</ul><p>
</p>
<p>An IM application SHOULD support all of the foregoing message types; if an application receives a message with no 'type' attribute or the application does not understand the value of the 'type' attribute provided, it MUST consider the message to be of type "normal" (i.e., "normal" is the default).  The "error" type MUST be generated only in response to an error related to a message received from another entity.
</p>
<p>Although the 'type' attribute is NOT REQUIRED, it is considered polite to mirror the type in any replies to a message; furthermore, some specialized applications (e.g., a multi-user chat service) MAY at their discretion enforce the use of a particular message type (e.g., type='groupchat').
</p>
<a name="rfc.section.2.1.2"></a><h4><a name="stanzas-message-children">2.1.2</a>&nbsp;Child Elements</h4>

<p>As described under <a href="#stanzas-extended">extended namespaces</a>, a message stanza MAY contain any properly-namespaced child element.
</p>
<p>In accordance with the default namespace declaration, by default a message stanza is in the 'jabber:client' or 'jabber:server' namespace, which defines certain allowable children of message stanzas.  If the message stanza is of type "error", it MUST include an &lt;error/&gt; child; for details, see <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a>.  Otherwise, the message stanza MAY contain any of the following child elements without an explicit namespace declaration:
</p>
<p>
<ol class="text">
<li>&lt;subject/&gt;
</li>
<li>&lt;body/&gt;
</li>
<li>&lt;thread/&gt;
</li>
</ol><p>
</p>
<a name="rfc.section.2.1.2.1"></a><h4><a name="stanzas-message-children-subject">2.1.2.1</a>&nbsp;Subject</h4>

<p>The &lt;subject/&gt; element contains XML character data that specifies the topic of the message.  The &lt;subject/&gt; element MUST NOT possess any attributes, with the exception of the 'xml:lang' attribute.  Multiple instances of the &lt;subject/&gt; element MAY be included for the purpose of providing alternate versions of the same subject, but only if each instance possesses an 'xml:lang' attribute with a distinct language value.  The &lt;subject/&gt; element MUST NOT contain mixed content (as defined in Section 3.2.2 of <a href="#XML" title="Bray, T., Paoli, J., Sperberg-McQueen, C. and E. Maler, Extensible Markup Language (XML) 1.0 (2nd ed), October 2000.">[XML]</a>).
</p>
<a name="rfc.section.2.1.2.2"></a><h4><a name="stanzas-message-children-body">2.1.2.2</a>&nbsp;Body</h4>

<p>The &lt;body/&gt; element contains XML character data that specifies the textual contents of the message; this child element is normally included but NOT REQUIRED.  The &lt;body/&gt; element MUST NOT possess any attributes, with the exception of the 'xml:lang' attribute.  Multiple instances of the &lt;body/&gt; element MAY be included but only if each instance possesses an 'xml:lang' attribute with a distinct language value.  The &lt;body/&gt; element MUST NOT contain mixed content (as defined in Section 3.2.2 of <a href="#XML" title="Bray, T., Paoli, J., Sperberg-McQueen, C. and E. Maler, Extensible Markup Language (XML) 1.0 (2nd ed), October 2000.">[XML]</a>).
</p>
<a name="rfc.section.2.1.2.3"></a><h4><a name="stanzas-message-children-thread">2.1.2.3</a>&nbsp;Thread</h4>

<p>The &lt;thread/&gt; element contains XML character data that specifies an identifier that is used for tracking a conversation thread (sometimes referred to as an "instant messaging session") between two entities.  The value of the &lt;thread/&gt; element is generated by the sender and that SHOULD be copied back in any replies.  If used, it MUST be unique to that conversation thread within the stream and MUST be consistent throughout that conversation (a client that receives a message from the same full JID but with a different thread ID MUST assume that the message in question exists outside the context of the existing conversation thread).  The use of the &lt;thread/&gt; element is OPTIONAL and is not used to identify individual messages, only conversations.  A message stanza MUST NOT contain more than one &lt;thread/&gt; element.  The &lt;thread/&gt; element MUST NOT possess any attributes.  The value of the &lt;thread/&gt; element MUST be treated as opaque by entities; no semantic meaning may be derived from it, and only exact comparisons may be made against it.  The &lt;thread/&gt; element MUST NOT contain mixed content (as defined in Section 3.2.2 of <a href="#XML" title="Bray, T., Paoli, J., Sperberg-McQueen, C. and E. Maler, Extensible Markup Language (XML) 1.0 (2nd ed), October 2000.">[XML]</a>).
</p>
<a name="rfc.section.2.2"></a><h4><a name="stanzas-presence">2.2</a>&nbsp;Presence Syntax</h4>

<p>Presence stanzas are used in the 'jabber:client' or 'jabber:server' namespace to express an entity's current availability status (offline or online, along with various sub-states of the latter and optional user-defined descriptive text), and to communicate that status to other entities.  Presence stanzas are also used to negotiate and manage subscriptions to the presence of other entities.
</p>
<a name="rfc.section.2.2.1"></a><h4><a name="stanzas-presence-type">2.2.1</a>&nbsp;Types of Presence</h4>

<p>The 'type' attribute of a presence stanza is OPTIONAL.  A presence stanza that does not possess a 'type' attribute is used to signal to the server that the sender is online and available for communication.  If included, the 'type' attribute specifies a lack of availability, a request to manage a subscription to another entity's presence, a request for another entity's current presence, or an error related to a previously-sent presence stanza.  If included, the 'type' attribute MUST have one of the following values:
</p>
<p>
<ul class="text">
<li>unavailable -- Signals that the entity is no longer available for communication.
</li>
<li>subscribe -- The sender wishes to subscribe to the recipient's presence.
</li>
<li>subscribed -- The sender has allowed the recipient to receive their presence.
</li>
<li>unsubscribe -- A notification that an entity is unsubscribing from another entity's presence.
</li>
<li>unsubscribed -- The subscription request has been denied or a previously-granted subscription has been cancelled.
</li>
<li>probe -- A request for an entity's current presence; SHOULD be generated only by a server and SHOULD NOT be generated by a client.
</li>
<li>error -- An error has occurred regarding processing or delivery of a previously-sent presence stanza.
</li>
</ul><p>
</p>
<p>For detailed information regarding presence semantics and the subscription model used in the context of XMPP-based instant messaging and presence applications, refer to <a href="#presence">Exchanging Presence Information</a> and <a href="#sub">Managing Subscriptions</a>.
</p>
<a name="rfc.section.2.2.2"></a><h4><a name="stanzas-presence-children">2.2.2</a>&nbsp;Child Elements</h4>

<p>As described under <a href="#stanzas-extended">extended namespaces</a>, a presence stanza MAY contain any properly-namespaced child element.
</p>
<p>In accordance with the default namespace declaration, by default a presence stanza is in the 'jabber:client' or 'jabber:server' namespace, which defines certain allowable children of presence stanzas.  If the presence stanza is of type "error", it MUST include an &lt;error/&gt; child; for details, see <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a>.  If the presence stanza possesses no 'type' attribute, it MAY contain any of the following child elements (note that the &lt;status/&gt; child MAY be sent in a presence stanza of type "unavailable" or, for historical reasons, "subscribe"):
</p>
<p>
<ol class="text">
<li>&lt;show/&gt;
</li>
<li>&lt;status/&gt;
</li>
<li>&lt;priority/&gt;
</li>
</ol><p>
</p>
<a name="rfc.section.2.2.2.1"></a><h4><a name="stanzas-presence-children-show">2.2.2.1</a>&nbsp;Show</h4>

<p>The OPTIONAL &lt;show/&gt; element contains XML character data that specifies the particular availability status of an entity or specific resource.  A presence stanza MUST NOT contain more than one &lt;show/&gt; element.  The &lt;show/&gt; element MUST NOT possess any attributes.  The XML character data contained in the &lt;show/&gt; element is not intended to be human-readable.  If provided, the CDATA value MUST be one of the following (additional availability types could be defined through a properly-namespaced child element of the presence stanza):
</p>
<p>
<ul class="text">
<li>away -- The entity or resource is temporarily away.
</li>
<li>chat -- The entity or resource is actively interested in chatting.
</li>
<li>xa -- The entity or resource is away for an extended period (xa = "eXtended Away").
</li>
<li>dnd -- The entity or resource is busy (dnd = "Do Not Disturb").
</li>
</ul><p>
</p>
<p>If no &lt;show/&gt; element is provided, the entity is assumed to be online and available.
</p>
<a name="rfc.section.2.2.2.2"></a><h4><a name="stanzas-presence-children-status">2.2.2.2</a>&nbsp;Status</h4>

<p>The OPTIONAL &lt;status/&gt; element contains a natural-language description of availability status.  It is normally used in conjunction with the show element to provide a detailed description of an availability state (e.g., "In a meeting").  The &lt;status/&gt; element MUST NOT possess any attributes, with the exception of the 'xml:lang' attribute.  Multiple instances of the &lt;status/&gt; element MAY be included but only if each instance possesses an 'xml:lang' attribute with a distinct language value.
</p>
<a name="rfc.section.2.2.2.3"></a><h4><a name="stanzas-presence-children-priority">2.2.2.3</a>&nbsp;Priority</h4>

<p>The OPTIONAL &lt;priority/&gt; element contains XML character data that specifies the priority level of the connected resource.  The value may be any integer between -128 and +127.  A presence stanza MUST NOT contain more than one &lt;priority/&gt; element.  The &lt;priority/&gt; element MUST NOT possess any attributes.  If no priority is provided, a server SHOULD consider the priority to be zero.  For information regarding the semantics of priority values in stanza routing within instant messaging and presence applications, refer to <a href="#rules">Server Rules for Handling XML Stanzas</a>.
</p>
<a name="rfc.section.2.3"></a><h4><a name="stanzas-iq">2.3</a>&nbsp;IQ Syntax</h4>

<p>IQ stanzas provide a structured request-response mechanism.  The basic semantics of that mechanism are defined in <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a>, whereas the specific semantics required to complete particular use cases are defined in all cases by an <a href="#stanzas-extended">extended namespace</a> (note that the 'jabber:client' and 'jabber:server' namespaces do not define any children of IQ stanzas).  This memo defines two such extended namespaces, one for <a href="#roster">Roster Management</a> and the other for <a href="#privacy">Blocking Communication</a>; however, an IQ stanza MAY contain structured information qualified by any extended namespace.
</p>
<a name="rfc.section.2.4"></a><h4><a name="stanzas-extended">2.4</a>&nbsp;Extended Namespaces</h4>

<p>While the three XML stanza kinds defined in the "jabber:client" or "jabber:server" namespace (along with their attributes and child elements) provide a basic level of functionality for messaging and presence, XMPP uses XML namespaces to extend the stanzas for the purpose of providing additional functionality.  Thus a message or presence MAY contain one or more optional child elements containing content that extends the meaning of the message (e.g., an XHTML-formatted version of the message body), and an IQ stanza MAY contain one such child element.  This child element MAY have any name and MUST possess an 'xmlns' namespace declaration (other than "jabber:client", "jabber:server", or "http://etherx.jabber.org/streams") that defines all data contained within the child element.
</p>
<p>Support for any given extended namespace is OPTIONAL on the part of any implementation (aside from the extended namespaces defined herein).  If an entity does not understand such a namespace, the entity's expected behavior depends on whether the entity is (1) the recipient or (2) an entity that is routing the stanza to the recipient:
</p>
<p>
<blockquote class="text"><dl>
<dt>Recipient:</dt>
<dd>If a recipient receives a stanza that contains a child element it does not understand, it SHOULD ignore that specific XML data, i.e., it SHOULD not process it or present it to a user or associated application (if any).  In particular:
          
<ul class="text">
<li>If an entity receives a message or presence stanza that contains XML data qualified by a namespace it does not understand, the portion of the stanza that is in the unknown namespace SHOULD be ignored.
</li>
<li>If an entity receives a message stanza whose only child element is qualified by a namespace it does not understand, it MUST ignore the entire stanza.
</li>
<li>If an entity receives an IQ stanza of type "get" or "set" containing a child element qualified by a namespace it does not understand, the entity SHOULD return an IQ stanza of type "error" with an error condition of &lt;feature-not-implemented/&gt;.
</li>
</ul><p>
</dd>
<dt>Router:</dt>
<dd>If a routing entity (usually a server) handles a stanza that contains a child element it does not understand, it SHOULD ignore the associated XML data by passing it on untouched to the recipient.
</dd>
</dl></blockquote><p>
</p>
<a name="session"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;Session Establishment</h3>

<p>Most instant messaging and presence applications based on XMPP are implemented via a client-server architecture that requires a client to establish a session on a server in order to engage in the expected instant messaging and presence activities.  However, there are several pre-conditions that MUST be met before a client can establish an instant messaging and presence session.  These are:
</p>
<p>
<ol class="text">
<li>Stream Authentication -- a client MUST complete stream authentication as documented in <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a> before attempting to establish a session or send any XML stanzas.
</li>
<li>Resource Binding -- after completing stream authentication, a client MUST bind a resource to the stream so that the client's address is of the form &lt;user@domain/resource&gt;.
</li>
</ol><p>
</p>
<p>If a server supports sessions, it MUST include a &lt;session/&gt; element qualified by the 'urn:ietf:params:xml:ns:xmpp-session' namespace in the stream features it advertises to a client after the completion of stream authentication as defined in <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a>:
</p>
<p>Server advertises session establishment feature to client:
</p><pre>
&lt;stream:stream
    xmlns='jabber:client'
    xmlns:stream='http://etherx.jabber.org/streams'
    id='c2s_345'
    from='example.com'
    version='1.0'>
&lt;stream:features>
  &lt;bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>
  &lt;session xmlns='urn:ietf:params:xml:ns:xmpp-session'>
&lt;/stream:features>
      </pre>

<p>Upon being so informed that session establishment is required (and after completing resource binding), the client SHOULD establish a session by sending to the server an IQ stanza of type "set" containing an empty &lt;session/&gt; child element qualified by the 'urn:ietf:params:xml:ns:xmpp-session' namespace:
</p>
<p>Step 1: Client requests session with server:
</p><pre>
&lt;iq from='someuser@example.com' 
    to='example.com' 
    type='set' 
    id='sess_1'>
  &lt;session xmlns='urn:ietf:params:xml:ns:xmpp-session'/>
&lt;/iq>
      </pre>

<p>Step 2: Server informs client that session has been created:
</p><pre>
&lt;iq from='example.com' 
    to='someuser@example.com' 
    type='result' 
    id='sess_1'/>
      </pre>

<p>Several error conditions are possible.  For example, the server may encounter an internal condition that prevents it from creating the session, the username or authorization identity may lack permissions to create a session, or there may already be an active session associated with a resource of the same name.
</p>
<p>If the server encounters an internal condition that prevents it from creating the session, it MUST return an error.
</p>
<p>Step 2 (alt): Server responds with error (internal server error):
</p><pre>
&lt;iq type='error' id='sess_1'>
  &lt;session xmlns='urn:ietf:params:xml:ns:xmpp-session'/>
  &lt;error type='wait'>
    &lt;internal-server-error
        xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
  &lt;/error>
&lt;/iq>
      </pre>

<p>If the username or resource is not allowed to create a session, the server MUST return an error (e.g., forbidden).
</p>
<p>Step 2 (alt): Server responds with error (username or resource not allowed to create session):
</p><pre>
&lt;iq type='error' id='sess_1'>
  &lt;session xmlns='urn:ietf:params:xml:ns:xmpp-session'/>
  &lt;error type='auth'>
    &lt;forbidden
        xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
  &lt;/error>
&lt;/iq>
      </pre>

<p>If there is already an active session of the same name, the server MUST either (1) terminate the active session and allow the newly-requested session, or (2) disallow the newly-requested session and maintain the existing session.  Which of these the server does is up to the implementation, although it is RECOMMENDED to implement case #1.  In case #1, the server SHOULD send a &lt;conflict/&gt; stream error to the active session; in case #2, the server SHOULD send a &lt;conflict/&gt; stanza error to the newly-requested session.
</p>
<p>Step 2 (alt): Server informs active session of resource conflict (case #1):
</p><pre>
&lt;stream:error>
  &lt;conflict xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>
&lt;/stream:error>
&lt;/stream:stream>
      </pre>

<p>Step 2 (alt): Server informs newly-requested session of resource conflict (case #2):
</p><pre>
&lt;iq type='error' id='sess_1'>
  &lt;session xmlns='urn:ietf:params:xml:ns:xmpp-session'/>
  &lt;error type='cancel'>
    &lt;conflict xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
  &lt;/error>
&lt;/iq>
      </pre>

<p>After establishing a session, a client SHOULD send initial presence and request its roster as described below, although these actions are NOT REQUIRED.
</p>
<p>Note: Before allowing the creation of instant messaging and presence sessions, a server MAY require prior account provisioning.  Possible methods for account provisioning include account creation by a server administrator as well as in-band account registration using the 'jabber:iq:register' namespace; the latter method is documented by the <a href="#JSF" title="Jabber Software Foundation, Jabber Software Foundation, .">Jabber Software Foundation</a>[JSF] at &lt;http://www.jabber.org/protocol/&gt; but is out of scope for this memo.
</p>
<a name="messaging"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;Exchanging Messages</h3>

<p>Exchanging messages is a basic use of XMPP and is brought about when a user generates a message stanza that is addressed to another entity.  As defined under <a href="#rules">Server Rules for Handling XML Stanzas</a>, the sender's server is responsible for delivering the message to the intended recipient (if the recipient is on the same server) or for routing the message to the recipient's server (if the recipient is on a different server).
</p>
<p>For information regarding the syntax of message stanzas as well as their defined attributes and child elements, refer to <a href="#stanzas-message">Message Syntax</a>.
</p>
<a name="rfc.section.4.1"></a><h4><a name="messaging-to">4.1</a>&nbsp;Specifying an Intended Recipient</h4>

<p>An instant messaging client SHOULD specify an intended recipient for a message by providing the JID of an entity other than the sender in the 'to' attribute of the &lt;message/&gt; stanza.  If the message is being sent in reply to a message previously received from an address of the form &lt;user@domain/resource&gt; (e.g., within the context of a chat session), the value of the 'to' address SHOULD be the full JID (&lt;user@domain/resource&gt;) rather than merely &lt;user@domain&gt; unless the sender has knowledge (via presence) that the intended recipient's resource is no longer available.  If the message is being sent outside the context of any existing chat session or received message, the value of the 'to' address SHOULD be of the form &lt;user@domain&gt; rather than &lt;user@domain/resource&gt;.
</p>
<a name="rfc.section.4.2"></a><h4><a name="messaging-types">4.2</a>&nbsp;Specifying a Message Type</h4>

<p>As noted, it is RECOMMENDED for a message stanza to possess a 'type' attribute whose value captures the conversational context (if any) of the message (see <a href="#stanzas-message-type">Type</a>).
</p>
<p>The following example shows a valid value of the 'type' attribute:
</p>
<p>Example: A message of a defined type:
</p><pre>
&lt;message
    to='romeo@example.net'
    from='juliet@example.com/balcony'
    type='chat'
    xml:lang='en'>
  &lt;body>Wherefore art thou, Romeo?&lt;/body>
&lt;/message>
        </pre>

<a name="rfc.section.4.3"></a><h4><a name="messaging-body">4.3</a>&nbsp;Specifying a Message Body</h4>

<p>A message stanza MAY (and often will) contain a child &lt;body/&gt; element whose XML character data specifies the primary meaning of the message (see <a href="#stanzas-message-children-body">Body</a>).
</p>
<p>Example: A message with a body:
</p><pre>
&lt;message
    to='romeo@example.net'
    from='juliet@example.com/balcony'
    type='chat'
    xml:lang='en'>
  &lt;body>Wherefore art thou, Romeo?&lt;/body>
  &lt;body xml:lang='cz'>Pro&amp;#x010D;e&amp;#x017D; jsi ty, Romeo?&lt;/body>
&lt;/message>
        </pre>

<a name="rfc.section.4.4"></a><h4><a name="messaging-subject">4.4</a>&nbsp;Specifying a Message Subject</h4>

<p>A message stanza MAY contain one or more child &lt;subject/&gt; elements specifying the topic of the message (see <a href="#stanzas-message-children-subject">Subject</a>).
</p>
<p>Example: A message with a subject:
</p><pre>
&lt;message
    to='romeo@example.net'
    from='juliet@example.com/balcony'
    type='chat'
    xml:lang='en'>
  &lt;subject>I implore you!&lt;/subject>
  &lt;subject 
      xml:lang='cz'>&amp;#x00DA;p&amp;#x011B;nliv&amp;#x011B; prosim!&lt;/subject>
  &lt;body>Wherefore art thou, Romeo?&lt;/body>
  &lt;body xml:lang='cz'>Pro&amp;#x010D;e&amp;#x017D; jsi ty, Romeo?&lt;/body>
&lt;/message>
        </pre>

<a name="rfc.section.4.5"></a><h4><a name="messaging-thread">4.5</a>&nbsp;Specifying a Conversation Thread</h4>

<p>A message stanza MAY contain a child &lt;thread/&gt; element specifying the conversation thread in which the message is situated, for the purpose of tracking the conversation (see <a href="#stanzas-message-children-thread">Thread</a>).
</p>
<p>Example: A threaded conversation:
</p><pre>
&lt;message
    to='romeo@example.net/orchard'
    from='juliet@example.com/balcony'
    type='chat'>
  &lt;body>Art thou not Romeo, and a Montague?&lt;/body>
  &lt;thread>e0ffe42b28561960c6b12b944a092794b9683a38&lt;/thread>
&lt;/message>

&lt;message
    to='juliet@example.com/balcony'
    from='romeo@example.net/orchard'
    type='chat'>
  &lt;body>Neither, fair saint, if either thee dislike.&lt;/body>
  &lt;thread>e0ffe42b28561960c6b12b944a092794b9683a38&lt;/thread>
&lt;/message>

&lt;message
    to='romeo@example.net/orchard'
    from='juliet@example.com/balcony'
    type='chat'>
  &lt;body>How cam'st thou hither, tell me, and wherefore?&lt;/body>
  &lt;thread>e0ffe42b28561960c6b12b944a092794b9683a38&lt;/thread>
&lt;/message>
        </pre>

<a name="presence"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;Exchanging Presence Information</h3>

<p>Exchanging presence information is made relatively straightforward within XMPP by using presence stanzas.  However, we see here a contrast to the handling of messages: although a client MAY send directed presence information to another entity, normally presence information is sent from a client to its server (with no 'to' address) and then broadcasted by the server to any entities that are subscribed to the presence of the sending entity (in the terminology of <a href="#IMP-MODEL" title="Day, M., Rosenberg, J. and H. Sugano, A Model for Presence and Instant Messaging, February 2000.">RFC 2778</a>[IMP-MODEL], we can say that the only watchers in XMPP are subscribers).  (Note: While presence information MAY be provided on a user's behalf by an automated service, normally it is provided by the user's client.)
</p>
<p>For information regarding the syntax of presence stanzas as well as their defined attributes and child elements, refer to <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a>.
</p>
<a name="rfc.section.5.1"></a><h4><a name="presence-resp">5.1</a>&nbsp;Client and Server Presence Responsibilities</h4>

<p>After establishing a session, a client SHOULD (but is NOT REQUIRED to) send initial presence to the server in order to signal its availability for communications.  As defined herein, the initial presence stanza (1) MUST possess no 'to' address (signalling that it is meant to be handled by the server on behalf of the client) and (2) MUST possess no 'type' attribute (signalling the user's availability).
</p>
<p>Upon receiving initial presence from a client, the user's server MUST do the following if there is not already one or more connected resources for the user (if there is already one or more connected resources for the user, the server obviously does not need to send the presence probes, since it already possesses the requisite information):
</p>
<p>
<ol class="text">
<li>Send presence probes (i.e., presence stanzas whose 'type' attribute is set to a value of "probe") from the full JID (&lt;user@somedomain/resource&gt;) of the user to the bare JID (&lt;contact@otherdomain&gt;) of any contacts to which the user is subscribed in order to determine if they are available; such contacts are those which are present in the user's roster with the 'subscription' attribute set to a value of "to" or "both".
</li>
<li>Broadcast initial presence from the full JID (&lt;user@somedomain/resource&gt;) of the user to the bare JID (&lt;contact@otherdomain&gt;) of any contacts that are subscribed to the user's presence; such contacts are those which are present in the user's roster with the 'subscription' attribute set to a value of "from" or "both".
</li>
</ol><p>
</p>
<p>Upon receiving a presence probe from the user, the contact's server MUST send to the user the last known availability information (i.e., the full XML of the last presence stanza) provided by each of the contact's active sessions (if there exist no active sessions, the server SHOULD NOT reply to the presence probe).  The contact's server MUST send this information subject to domain-specific access rules, and only if the user is in the contact's roster with a subscription state of "from" or "both" and the contact has not blocked outbound presence notifications to the user's bare or full JID (as defined under <a href="#privacy-presenceout">Blocking Outbound Presence Notifications</a>).  (Note: If a server receives a presence probe from a subdomain of the server's hostname or another such trusted service, it MAY provide presence information about the user to that entity.)
</p>
<p>Upon receiving initial presence from the user, the contact's server MUST deliver the user's presence stanza to the full JIDs (&lt;contact@otherdomain/resource&gt;) associated with all of the contact's active sessions, but only if the user is in the contact's roster with a subscription state of "to" or "both" and the contact has not blocked inbound presence notifications from the user's bare or full JID (as defined under <a href="#privacy-presencein">Blocking Inbound Presence Notifications</a>).
</p>
<p>If the user's server receives a presence stanza of type "error" in response to the initial presence that it sent to a contact on behalf of the user, it SHOULD NOT send further presence updates to that contact (until and unless it receives a presence probe from the contact).
</p>
<p>After sending initial presence, the user MAY update its presence information for broadcasting at any time during its active session by sending a presence stanza with no 'to' address and either no 'type' attribute or a 'type' attribute with a value of "unavailable".  (Note: A user's client SHOULD NOT send a presence update to broadcast information that changes independently of the user's presence and availability.) If the presence stanza lacks a 'type' attribute (i.e., expresses availability), the user's server MUST broadcast the full XML of that presence stanza to all contacts (1) that are in the user's roster with a subscription type of "from" or "both", (2) to whom the user has not blocked outbound presence, and (3) from whom the server has not received a presence error during the user's session.  If the presence stanza has a 'type' attribute set to a value of "unavailable", the user's server MUST broadcast the full XML of that presence stanza to all contacts meeting the three conditions just mentioned, as well as to any entities to which the user has sent directed available presence during the user's session (if the user has not yet sent directed unavailable presence to that entity).
</p>
<p>A user MAY send directed presence to another entity (i.e., a presence stanza with a 'to' attribute whose value is the JID of the other entity and with either no 'type' attribute or a 'type' attribute whose value is "unavailable").  There are three possible cases:
</p>
<p>
<ol class="text">
<li>If the user sends directed presence to a contact that is in the user's roster with a subscription type of "from" or "both" after having sent initial presence and before sending unavailable presence broadcast, the user's server MUST route or deliver the full XML of that presence stanza (subject to privacy rules) but SHOULD NOT otherwise modify the contact's status regarding presence broadcast (i.e., it SHOULD include the contact's JID in any subsequent presence broadcasts initiated by the user).
</li>
<li>If the user sends directed presence to an entity that is not in the user's roster with a subscription type of "from" or "both" after having sent initial presence and before sending unavailable presence broadcast, the user's server MUST route or deliver the full XML of that presence stanza to the entity but MUST NOT modify the contact's status regarding available presence broadcast (i.e., it MUST NOT include the entity's JID in any subsequent broadcasts of available presence initiated by the user); however, if the connected resource from which the user sent the directed presence become unavailable, the user's server MUST broadcast that unavailable presence to the entity (if the user has not yet sent directed unavailable presence to that entity).
</li>
<li>If the user sends directed presence without first sending initial presence or after having sent unavailable presence broadcast, the user's server MUST treat the entities to which the user sends directed presence in the same way that it treats the entities listed in case 2 above.
</li>
</ol><p>
</p>
<p>Before ending its session with a server, a client SHOULD gracefully become unavailable by sending a final presence stanza that possesses no 'to' attribute and that possesses a 'type' attribute whose value is "unavailable" (optionally, the final presence stanza MAY contain one or more &lt;status/&gt; elements specifying the reason why the user is no longer available).  However, the user's server MUST NOT depend on receiving final presence from an available resource, since the resource may become unavailable unexpectedly.  If the user's server detects that one of the user's resources has become unavailable for any reason (either gracefully or ungracefully), it MUST broadcast unavailable presence to all contacts (1) that are in the user's roster with a subscription type of "from" or "both", (2) to whom the user has not blocked outbound presence, and (3) from whom the server has not received a presence error during the user's session; the user's server MUST also send that unavailable presence stanza to any entities to which the user has sent directed presence during the user's session for that resource (if the user has not yet sent directed unavailable presence to that entity).  Any presence stanza with no 'type' attribute and no 'to' attribute that is sent after sending directed unavailable presence or broadcasted unavailable presence MUST be broadcasted by the server to all subscribers.
</p>
<a name="rfc.section.5.2"></a><h4><a name="presence-show">5.2</a>&nbsp;Specifying Availability Status</h4>

<p>A client MAY provide further information about its availability status by using the &lt;show/&gt; element (see <a href="#stanzas-presence-children-show">Show</a>).
</p>
<p>Example: Availability status:
</p><pre>
&lt;presence>
  &lt;show>dnd&lt;/show>
&lt;/presence>
        </pre>

<a name="rfc.section.5.3"></a><h4><a name="presence-status">5.3</a>&nbsp;Specifying Detailed Status Information</h4>

<p>In conjunction with the  &lt;show/&gt; element, a client MAY provide detailed status information by using the &lt;status/&gt; element (see <a href="#stanzas-presence-children-status">Status</a>).
</p>
<p>Example: Detailed status information:
</p><pre>
&lt;presence xml:lang='en'>
  &lt;show>dnd&lt;/show>
  &lt;status>Wooing Juliet&lt;/status>
  &lt;status xml:lang='cz'>Ja dvo&amp;#x0159;&amp;#x00ED;m Juliet&lt;/status>
&lt;/presence>
        </pre>

<a name="rfc.section.5.4"></a><h4><a name="presence-priority">5.4</a>&nbsp;Specifying Presence Priority</h4>

<p>A client MAY provide a priority for its resource by using the &lt;priority/&gt; element (see <a href="#stanzas-presence-children-priority">Priority</a>).
</p>
<p>Example: Presence priority:
</p><pre>
&lt;presence xml:lang='en'>
  &lt;show>dnd&lt;/show>
  &lt;status>Wooing Juliet&lt;/status>
  &lt;status xml:lang='cz'>Ja dvo&amp;#x0159;&amp;#x00ED;m Juliet&lt;/status>
  &lt;priority>1&lt;/priority>
&lt;/presence>
        </pre>

<a name="rfc.section.5.5"></a><h4><a name="presence-examples">5.5</a>&nbsp;Presence Examples</h4>

<p>The examples in this section illustrate the presence-related protocols described above.  The user is romeo@example.net, he has authorized a resource "orchard", and he has the following individuals in his roster:
</p>
<p>
<ul class="text">
<li>juliet@example.com (subscription="both" and she has two active sessions, one whose resource is "chamber" and another whose resource is "balcony")
</li>
<li>benvolio@example.org (subscription="to")
</li>
<li>mercutio@example.org (subscription="from")
</li>
</ul><p>
</p>
<p>Example 1: User sends initial presence:
</p><pre>
&lt;presence/>
        </pre>

<p>Example 2: User's server sends presence probes to contacts with subscription="to" and subscription="both" on behalf of the user's connected resource:
</p><pre>
&lt;presence
    type='probe'
    from='romeo@example.net/orchard'
    to='juliet@example.com'/>

&lt;presence
    type='probe'
    from='romeo@example.net/orchard'
    to='benvolio@example.org'/>
            </pre>

<p>Example 3: User's server sends initial presence to contacts with subscription="from" and subscription="both" on behalf of the user's connected resource:
</p><pre>
&lt;presence
    from='romeo@example.net/orchard'
    to='juliet@example.com'/>

&lt;presence
    from='romeo@example.net/orchard'
    to='mercutio@example.org'/>
            </pre>

<p>Example 4: Contacts' server replies to presence probe on behalf of all of the contact's available resources:
</p><pre>
&lt;presence
    from='juliet@example.com/balcony'
    to='romeo@example.net/orchard'
    xml:lang='en'>
  &lt;show>away&lt;/show>
  &lt;status>be right back&lt;/status>
  &lt;priority>0&lt;/priority>
&lt;/presence>

&lt;presence
    from='juliet@example.com/chamber'
    to='romeo@example.net/orchard'>
  &lt;priority>1&lt;/priority>
&lt;/presence>

&lt;presence
    from='benvolio@example.org/pda'
    to='romeo@example.net/orchard'
    xml:lang='en'>
  &lt;show>dnd&lt;/show>
  &lt;status>gallivanting&lt;/status>
&lt;/presence>
        </pre>

<p>Example 5: Contact's server delivers user's initial presence to all of the contact's available resources or returns error to user:
</p><pre>
&lt;presence
    from='romeo@example.net/orchard'
    to='juliet@example.com/chamber'/>

&lt;presence
    from='romeo@example.net/orchard'
    to='juliet@example.com/balcony'/>

&lt;presence
    type='error'
    from='mercutio@example.org'
    to='romeo@example.net/orchard'>
  &lt;error type='cancel'>
    &lt;gone xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
  &lt;/error>
&lt;/presence>
    </pre>

<p>Example 6: User sends directed presence to another user not in his roster:
</p><pre>
&lt;presence
    from='romeo@example.net/orchard'
    to='nurse@example.com'
    xml:lang='en'>
  &lt;show>dnd&lt;/show>
  &lt;status>courting Juliet&lt;/status>
  &lt;priority>0&lt;/priority>
&lt;/presence>
        </pre>

<p>Example 7: User sends updated available presence information for broadcasting:
</p><pre>
&lt;presence xml:lang='en'>
  &lt;show>away&lt;/show>
  &lt;status>I shall return!&lt;/status>
  &lt;priority>1&lt;/priority>
&lt;/presence>
        </pre>

<p>Example 8: Updated presence information is delivered only to one contact (not those from whom an error was received or to whom the user sent directed presence):
</p><pre>
&lt;presence
    from='romeo@example.net/orchard'
    to='juliet@example.com/chamber'
    xml:lang='en'>
  &lt;show>away&lt;/show>
  &lt;status>I shall return!&lt;/status>
  &lt;priority>1&lt;/priority>
&lt;/presence>

&lt;presence
    from='romeo@example.net/orchard'
    to='juliet@example.com/balcony'
    xml:lang='en'>
  &lt;show>away&lt;/show>
  &lt;status>I shall return!&lt;/status>
  &lt;priority>1&lt;/priority>
&lt;/presence>
        </pre>

<p>Example 9: One of the contact's resources sends final presence:
</p><pre>
&lt;presence type='unavailable'/>
        </pre>

<p>Example 10: Contact's server sends unavailable presence information to user:
</p><pre>
&lt;presence
    type='unavailable'
    from='juliet@example.com/balcony'
    to='romeo@example.net/orchard'/>
        </pre>

<p>Example 11: User sends final presence:
</p><pre>
&lt;presence type='unavailable' xml:lang='en'>
  &lt;status>gone home&lt;/status>
&lt;/presence>
        </pre>

<p>Example 12: Unavailable presence information is delivered to contact's one remaining resource as well as to the person to whom the user sent directed presence:
</p><pre>
&lt;presence
    type='unavailable'
    from='romeo@example.net/orchard'
    to='juliet@example.com/chamber'
    xml:lang='en'>
  &lt;status>gone home&lt;/status>
&lt;/presence>

&lt;presence
    from='romeo@example.net/orchard'
    to='nurse@example.com'
    xml:lang='en'>
  &lt;status>gone home&lt;/status>
&lt;/presence>
        </pre>

<a name="sub"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;Managing Subscriptions</h3>

<p>In order to protect the privacy of instant messaging users and any other entities, presence and availability information is disclosed only to other entities that the user has approved.  When a user has agreed that another entity may view its presence, the entity is said to have a subscription to the user's presence information.  A subscription lasts across sessions; indeed, it lasts until the subscriber unsubscribes or the subscribee cancels the previously-granted subscription.  Subscriptions are managed within XMPP by sending presence stanzas containing specially-defined attributes.
</p>
<p>Note: There are important interactions between subscriptions and rosters; these are defined under <a href="#int">Integration of Roster Items and Presence Subscriptions</a>, and the reader must refer to that section for a complete understanding of presence subscriptions.
</p>
<a name="rfc.section.6.1"></a><h4><a name="sub-request">6.1</a>&nbsp;Requesting a Subscription</h4>

<p>A request to subscribe to another entity's presence is made by sending a presence stanza of type "subscribe".
</p>
<p>Example: Sending a subscription request:
</p><pre>
&lt;presence to='juliet@example.com' type='subscribe'/>
        </pre>

<p>If the subscription request is being sent to another instant messaging user, the JID supplied in the 'to' attribute SHOULD be of the form &lt;contact@otherdomain&gt; rather than &lt;contact@otherdomain/resource&gt;.
</p>
<p>A user's server MUST NOT automatically approve subscription requests on the user's behalf.  All subscription requests MUST be directed to the user's client.  If there is no available resource associated with the user when the subscription request is received by the server, the user's server MUST store the subscription request offline for delivery when the user next becomes available.  (Note: If a resource has authorized a session but has not provided initial presence, the server SHOULD NOT consider it to be available and therefore SHOULD NOT send subscription requests to it.)
</p>
<a name="rfc.section.6.2"></a><h4><a name="sub-handle">6.2</a>&nbsp;Handling a Subscription Request</h4>

<p>When a client receives a subscription request from another entity, it MUST either approve the request by sending a presence stanza of type "subscribed" or refuse the request by sending a presence stanza of type "unsubscribed".
</p>
<p>Example: Approving a subscription request:
</p><pre>
&lt;presence to='romeo@example.net' type='subscribed'/>
        </pre>

<p>Example: Refusing a presence subscription request:
</p><pre>
&lt;presence to='romeo@example.net' type='unsubscribed'/>
        </pre>

<a name="rfc.section.6.3"></a><h4><a name="sub-cancel">6.3</a>&nbsp;Cancelling a Subscription from Another Entity</h4>

<p>If a user would like to cancel a previously-granted subscription request, it sends a presence stanza of type "unsubscribed".
</p>
<p>Example: Cancelling a previously granted subscription request:
</p><pre>
&lt;presence to='romeo@example.net' type='unsubscribed'/>
        </pre>

<a name="rfc.section.6.4"></a><h4><a name="sub-unsub">6.4</a>&nbsp;Unsubscribing from Another Entity's Presence</h4>

<p>If a user would like to unsubscribe from the presence of another entity, it sends a presence stanza of type "unsubscribe".
</p>
<p>Example: Unsubscribing from an entity's presence:
</p><pre>
&lt;presence to='juliet@example.com' type='unsubscribe'/>
        </pre>

<a name="roster"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;Roster Management</h3>

<p>In XMPP, one's contact list is called a roster, which consists of any number of specific roster items, each roster item being identified by a unique JID (usually of the form &lt;contact@otherdomain&gt;).  A user's roster is stored by the user's server on the user's behalf so that the user may access roster information from any available resource.
</p>
<p>Note: There are important interactions between rosters and subscriptions; these are defined under <a href="#int">Integration of Roster Items and Presence Subscriptions</a>, and the reader must refer to that section for a complete understanding of roster management.
</p>
<a name="rfc.section.7.1"></a><h4><a name="roster-syntax">7.1</a>&nbsp;Syntax and Semantics</h4>

<p>Rosters are managed using IQ stanzas, specifically by means of a &lt;query/&gt; child element qualified by the 'jabber:iq:roster' namespace.  The &lt;query/&gt; element MAY contain one or more &lt;item/&gt; children, each describing a unique roster item or "contact".
</p>
<p>The "key" or unique identifier for each roster item is a JID, encapsulated in the required 'jid' attribute of the &lt;item/&gt; element.  The value of the 'jid' attribute SHOULD be of the form &lt;user@somedomain&gt;, especially if the item is associated with another (human) instant messaging user.
</p>
<p>The state of the presence subscription in relation to a roster item is captured in the 'subscription' attribute of the &lt;item/&gt; element.  Allowable values for this attribute are:
</p>
<p>
<ul class="text">
<li>"none" -- the user does not have a subscription to the contact, and the contact does not have a subscription to the user
</li>
<li>"to" -- the user has a subscription to the contact, but the contact does not have a subscription to the user
</li>
<li>"from" -- the contact has a subscription to the user, but the user does not have a subscription to the contact
</li>
<li>"both" -- both the user and the contact have subscriptions to each other
</li>
</ul><p>
</p>
<p>Each &lt;item/&gt; element MAY contain a 'name' attribute, which sets the "nickname" to be associated with the JID, as determined by the user (not the contact).  The value of the 'name' attribute is opaque.
</p>
<p>Each &lt;item/&gt; element MAY contain one or more &lt;group/&gt; child elements, for use in collecting roster items into various categories.  The CDATA text of the &lt;group/&gt; element is opaque.
</p>
<a name="rfc.section.7.2"></a><h4><a name="roster-rules">7.2</a>&nbsp;Business Rules</h4>

<p>A server MUST ignore any 'to' address on a roster "set", and MUST treat any roster "set" as applying to the sender.  For added safety, a client SHOULD check the "from" address of a roster "push" to ensure that it is from a trusted source; specifically, the stanza SHOULD have no 'from' attribute (i.e., implicitly from the server) or the JID contained in the 'from' attribute SHOULD match the user's bare JID or full JID; otherwise, the client SHOULD ignore the roster "push".
</p>
<a name="rfc.section.7.3"></a><h4><a name="roster-login">7.3</a>&nbsp;Retrieving One's Roster on Login</h4>

<p>Upon connecting to the server, a client SHOULD request the roster (however, because receiving the roster may not be desirable for all resources, e.g., a connection with limited bandwidth, the client's request for the roster is NOT REQUIRED).  If an available resource does not request the roster during a session, the server SHOULD NOT send it presence subscriptions and associated roster updates.
</p>
<p>Example: Client requests current roster from server:
</p><pre>
&lt;iq from='juliet@example.com/balcony' type='get' id='roster_1'>
  &lt;query xmlns='jabber:iq:roster'/>
&lt;/iq>
        </pre>

<p>Example: Client receives roster from the server:
</p><pre>
&lt;iq to='juliet@example.com/balcony' type='result' id='roster_1'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item jid='romeo@example.net'
          name='Romeo'
          subscription='both'>
      &lt;group>Friends&lt;/group>
    &lt;/item>
    &lt;item jid='mercutio@example.org'
          name='Mercutio'
          subscription='from'>
      &lt;group>Friends&lt;/group>
    &lt;/item>
    &lt;item jid='benvolio@example.org'
          name='Benvolio'
          subscription='both'>
      &lt;group>Friends&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>
        </pre>

<a name="rfc.section.7.4"></a><h4><a name="roster-add">7.4</a>&nbsp;Adding a Roster Item</h4>

<p>At any time, a user MAY add an item to his or her roster.
</p>
<p>Example: Client adds a new item:
</p><pre>
&lt;iq from='juliet@example.com/balcony' type='set' id='roster_2'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item jid='nurse@example.com'
          name='Nurse'>
      &lt;group>Servants&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>
        </pre>

<p>The server MUST update the roster information in persistent storage, and also push the change out to all of the user's available resources that have requested the roster.  This "roster push" consists of an IQ set from the server to the client and enables all available resources to remain in sync with the server-based roster information.
</p>
<p>Example: Server (1) pushes the updated roster information to all available resources and (2) replies with an IQ result to the sending resource:
</p><pre>
&lt;iq to='juliet@example.com/balcony' type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item jid='nurse@example.com'
          name='Nurse'
          subscription='none'>
      &lt;group>Servants&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;iq to='juliet@example.com/chamber' type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item jid='nurse@example.com'
          name='Nurse'
          subscription='none'>
      &lt;group>Servants&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;iq to='juliet@example.com/balcony' type='result' id='roster_2'/>
        </pre>

<p>Example: Connected resources reply with an IQ result to the server:
</p><pre>
&lt;iq from='juliet@example.com/balcony'
    to='example.com'
    type='result'/>
&lt;iq from='juliet@example.com/chamber'
    to='example.com'
    type='result'/>
        </pre>

<a name="rfc.section.7.5"></a><h4><a name="roster-update">7.5</a>&nbsp;Updating a Roster Item</h4>

<p>Updating an existing roster item (e.g., changing the group) is done in the same way as adding a new roster item, i.e., by sending the roster item in an IQ set to the server.
</p>
<p>Example: User updates roster item (added group):
</p><pre>
&lt;iq from='juliet@example.com/chamber' type='set' id='roster_3'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item jid='romeo@example.net'
          name='Romeo'
          subscription='both'>
      &lt;group>Friends&lt;/group>
      &lt;group>Lovers&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As with adding a roster item, when updating a roster item the server MUST update the roster information in persistent storage, and also initiate a roster push to all of the user's available resources that have requested the roster.
</p>
<a name="rfc.section.7.6"></a><h4><a name="roster-delete">7.6</a>&nbsp;Deleting a Roster Item</h4>

<p>At any time, a user MAY delete an item from its roster by doing an IQ set and making sure that the value of the 'subscription' attribute is "remove" (a compliant server MUST ignore any other values of the 'subscription' attribute when received from a client).
</p>
<p>Example: Client removes an item:
</p><pre>
&lt;iq from='juliet@example.com/balcony' type='set' id='roster_4'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item jid='nurse@example.com' subscription='remove'/>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As with adding a roster item, when deleting a roster item the server MUST update the roster information in persistent storage, initiate a roster push to all of the user's available resources that have requested the roster (with the 'subscription' attribute set to a value of "remove"), and send an IQ result to the initiating resource.
</p>
<p>For further information about the implications of this command, see <a href="#int-remove">Removing a Roster Item and Cancelling All Subscriptions</a>.
</p>
<a name="int"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;Integration of Roster Items and Presence Subscriptions</h3>

<a name="rfc.section.8.1"></a><h4><a name="int-overview">8.1</a>&nbsp;Overview</h4>

<p>Some level of integration between roster items and presence subscriptions is normally expected by an instant messaging user regarding the user's subscriptions to and from other contacts.  This section describes the level of integration that MUST be supported within XMPP instant messaging applications.
</p>
<p>There are four primary subscription states:
</p>
<p>
<ul class="text">
<li>None -- Neither the user nor the contact is subscribed to the other's presence
</li>
<li>To -- The user is subscribed to the contact's presence but there is no subscription from the contact to the user
</li>
<li>From -- There is a subscription from the contact to the user, but the user has not subscribed to the contact's presence
</li>
<li>Both -- Both the user and the contact are subscribed to each other's presence (i.e., the union of 'from' and 'to')
</li>
</ul><p>
</p>
<p>Each of these states is reflected in the roster of both the user and the contact, thus resulting in durable subscription states.  Narrative explanations of how these subscription states interact with roster items in order to complete certain defined use cases are provided in the following sub-sections.  Full details regarding server and client handling of all subscription states (including pending states between the primary states listed above) is provided in <a href="#substates">Subscription States</a>.
</p>
<p>If a connected resource does not both send initial presence and request the roster, the server SHOULD NOT send it presence subscription requests or roster pushes.
</p>
<p>The 'from' and 'to' addresses are OPTIONAL in roster pushes; if included, their values SHOULD be the full JID of the resource for that session.  A client MUST acknowledge each roster push with an IQ stanza of type "result" (for the sake of brevity, these stanzas are not shown in the following examples but are required by <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a>).
</p>
<a name="rfc.section.8.2"></a><h4><a name="int-sub">8.2</a>&nbsp;User Subscribes to Contact</h4>

<p>The process by which a user subscribes to a contact, including the interaction between roster items and subscription states, is defined below.
</p>
<p>
<ol class="text">
<li>In preparation for being able to render the contact in the user's client interface and for the server to keep track of the subscription, the user's client SHOULD perform a "roster set" for the new roster item.  This request consists of an IQ stanza of type='set' containing a &lt;query/&gt; element in the 'jabber:iq:roster' namespace, which in turn contains an &lt;item/&gt; element that defines the new roster item; the &lt;item/&gt; element MUST possess a 'jid' attribute, MAY possess a 'name' attribute, MUST NOT possess a 'subscription' attribute, and MAY contain one or more &lt;group/&gt; child elements:
          </p>
<pre>
&lt;iq type='set' id='int1'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='contact@otherdomain'
        name='MyContact'>
      &lt;group>MyBuddies&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>
          </pre>
<p>

</li>
<li>As a result, the user's server (1) MUST initiate a roster push for the new roster item to all available resources associated with this user that have requested the roster, setting the 'subscription' attribute to a value of "none"; and (2) MUST reply with an IQ stanza of type='result':
          </p>
<pre>
&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='contact@otherdomain'
        subscription='none'
        name='MyContact'>
      &lt;group>MyBuddies&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;iq type='result' id='int1'/>
          </pre>
<p>

</li>
<li>If the user wants to request a subscription to the contact's presence, the user's client MUST send a presence stanza of type='subscribe' to the contact:
          </p>
<pre>
&lt;presence to='contact@otherdomain' type='subscribe'/>
          </pre>
<p>

</li>
<li>As a result, the user's server MUST initiate a second roster push to all of the user's available resources that have requested the roster, setting the contact to the pending sub-state of the 'none' subscription state; this pending sub-state is denoted by the inclusion of the ask='subscribe' attribute in the roster item:
          </p>
<pre>
&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='contact@otherdomain'
        subscription='none'
        ask='subscribe'
        name='MyContact'>
      &lt;group>MyBuddies&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>
          </pre>
<p>

<p>Note: If the user did not create a roster item before sending the subscription request, the server MUST now create one on behalf of the user and send a roster push to all of the user's available resources that have requested the roster, absent the 'name' attribute and the &lt;group/&gt; child.
</p>
</li>
<li>The user's server MUST also stamp the presence stanza of type "subscribe" with the user's bare JID (i.e., &lt;user@somedomain&gt;) as the 'from' address.  If the contact is served by a different host than the user, the user's server MUST route the presence stanza to the contact's server for delivery to the contact (this case is assumed throughout; however, if the contact is served by the same host, then the server can simply deliver the presence stanza directly):
          <pre>
&lt;presence
    from='user@somedomain'
    to='contact@otherdomain'
    type='subscribe'/>
          </pre>

</li>
<li>Upon receiving the presence stanza of type "subscribe" addressed to the contact, the contact's server must determine if there is at least one active session in which the contact has sent available presence and has requested the roster.  If so, it MUST deliver the subscription request to the contact (if not, the contact's server MUST store the subscription request offline for delivery when this condition is next met).  No matter when the subscription request is delivered, the contact must decide whether or not to approve it (subject to configured preferences, the contact's client MAY approve or refuse the subscription request without presenting it to the contact).  Here we assume the "happy path" that the contact approves the subscription request (the alternate flow of declining the subscription request is defined in <a href="#int-sub-alt">Section 8.2.1</a>).  In this case, the contact's client (1) SHOULD perform a roster set specifying the desired nickname and group for the user (if any); and (2) MUST send a presence stanza of type "subscribed" to the user in order to approve the subscription request.
          <pre>
&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='user@somedomain'
        name='SomeUser'>
      &lt;group>SomeGroup&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;presence to='user@somedomain' type='subscribed'/>
          </pre>

</li>
<li>As a result, the contact's server (1) MUST initiate a roster push to all available resources associated with the contact that have requested the roster, containing a roster item for the user with the subscription state set to 'from'; (2) MUST route the presence stanza of type "subscribed" to the user; and (3) MUST send available presence from all of the contact's available resources to the user:
          <pre>
&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='user@somedomain'
        subscription='from'
        name='SomeUser'>
      &lt;group>SomeGroup&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;presence
    from='contact@otherdomain/resource'
    to='user@somedomain'
    type='subscribed'/>

&lt;presence
    from='contact@otherdomain/resource'
    to='user@somedomain'/>
          </pre>

</li>
<li>Upon receiving the presence stanza of type "subscribed" addressed to the user, the user's server MUST first verify that the contact is in the user's roster with either of the following states: (a) subscription='none' and ask='subscribe' or (b) subscription='from' and ask='subscribe'.  If the contact is not in the user's roster with either of those states, the user's server MUST silently ignore the presence stanza of type "subscribed" (i.e., it MUST NOT route it to the user, modify the user's roster, or generate a roster push to the user's available resources).  If the contact is in the user's roster with either of those states, the user's server (1) MUST deliver the presence stanza of type "subscribed" from the contact to the user; (2) MUST initiate a roster push to all of the user's available resources that have requested the roster, containing an updated roster item for the contact with the 'subscription' attribute set to a value of "to"; and (3) MUST deliver the available presence stanza received from each of the contact's available resources to each of the user's available resources:
          <pre>
&lt;presence
    to='user@somedomain'
    from='contact@otherdomain'
    type='subscribed'/>

&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='contact@otherdomain'
        subscription='to'
        name='MyContact'>
      &lt;group>MyBuddies&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;presence
    from='contact@otherdomain/resource'
    to='user@somedomain/resource'/>
          </pre>

</li>
<li>Upon receiving the presence stanza of type "subscribed", the user SHOULD acknowledge receipt of that subscription state notification through either "affirming" it by sending a presence stanza of type "subscribe" to the contact or "denying" it by sending a presence stanza of type "unsubscribe" to the contact; this step does not necessarily affect the subscription state (see <a href="#substates">Subscription States</a> for details), but instead lets the user's server know that it MUST no longer send notification of the subscription state change to the user (see <a href="#substates-ack">Section 9.6</a>).
</li>
</ol><p>
</p>
<p>From the perspective of the user, there now exists a subscription to the contact; from the perspective of the contact, there now exists a subscription from the user.  (Note: If at this point the user sends another subscription request to the contact, the user's server MUST silently ignore that request.)
</p>
<a name="rfc.section.8.2.1"></a><h4><a name="int-sub-alt">8.2.1</a>&nbsp;Alternate Flow: Contact Declines Subscription Request</h4>

<p>The above activity flow represents the "happy path" related to the user's subscription request to the contact.  The main alternate flow occurs if the contact refuses the user's subscription request.
</p>
<p>
<ol class="text">
<li>If the contact wants to refuse the request, the contact's client MUST send a presence stanza of type "unsubscribed" to the user (instead of the presence stanza of type "subscribed" sent in Step 6 of <a href="#int-sub">Section 8.2</a>):
            </p>
<pre>
&lt;presence to='user@somedomain' type='unsubscribed'/>
            </pre>
<p>

</li>
<li>As a result, the contact's server MUST route the presence stanza of type "unsubscribed" to the user, first stamping the 'from' address as the bare JID (&lt;contact@otherdomain&gt;) of the contact:
            </p>
<pre>
&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='unsubscribed'/>
            </pre>
<p>

</li>
<li>Upon receiving the presence stanza of type "unsubscribed" addressed to the user, the user's server (1) MUST deliver that presence stanza to the user and (2) MUST initiate a roster push to all of the user's available resources that have requested the roster, containing an updated roster item for the contact with the 'subscription' attribute set to a value of "none" and with no 'ask' attribute:
            </p>
<pre>
&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='unsubscribed'/>

&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='contact@otherdomain'
        subscription='none'
        name='MyContact'>
      &lt;group>MyBuddies&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>
            </pre>
<p>

</li>
<li>Upon receiving the presence stanza of type "unsubscribed", the user SHOULD acknowledge receipt of that subscription state notification through either "affirming" it by sending a presence stanza of type "unsubscribe" to the contact or "denying" it by sending a presence stanza of type "subscribe" to the contact; this step does not necessarily affect the subscription state (see <a href="#substates">Subscription States</a> for details), but instead lets the user's server know that it MUST no longer send notification of the subscription state change to the user (see <a href="#substates-ack">Section 9.6</a>).
</li>
</ol><p>
</p>
<p>As a result of this activity, the contact is now in the user's roster with a subscription state of "none", whereas the user is not in the contact's roster at all.
</p>
<a name="rfc.section.8.3"></a><h4><a name="int-mutual">8.3</a>&nbsp;Creating a Mutual Subscription</h4>

<p>The user and contact can build on the foregoing to create a mutual subscription (i.e., a subscription of type "both").  The process is defined below.
</p>
<p>
<ol class="text">
<li>If the contact wants to create a mutual subscription, the contact MUST send a subscription request to the user (subject to configured preferences, the contact's client MAY send this automatically):
          </p>
<pre>
&lt;presence to='user@somedomain' type='subscribe'/>
          </pre>
<p>

</li>
<li>As a result, the contact's server (1) MUST initiate a roster push to all available resources associated with the contact that have requested the roster, with the user still in the 'from' subscription state but with a pending 'to' subscription denoted by the inclusion of the ask='subscribe' attribute in the roster item; and (2) MUST route the presence stanza of type "subscribe" to the user, first stamping the 'from' address as the bare JID (&lt;contact@otherdomain&gt;) of the contact:
          </p>
<pre>
&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='user@somedomain'
        subscription='from'
        ask='subscribe'
        name='SomeUser'>
      &lt;group>SomeGroup&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='subscribe'/>
          </pre>
<p>

</li>
<li>Upon receiving the presence stanza of type "subscribe" addressed to the user, the user's server must determine if there is at least one active session in which the user has sent available presence and has requested the roster.  If so, the user's server MUST deliver the subscription request to the user (if not, it MUST store the subscription request offline for delivery when this condition is next met).  No matter when the subscription request is delivered, the user must then decide whether or not to approve it (subject to configured preferences, the user's client MAY approve or refuse the subscription request without presenting it to the user).  Here we assume the "happy path" that the user approves the subscription request (the alternate flow of declining the subscription request is defined in <a href="#int-mutual-alt">Section 8.3.1</a>).  In this case, the user's client MUST send a presence stanza of type "subscribed" to the contact in order to approve the subscription request.
          </p>
<pre>
&lt;presence to='contact@otherdomain' type='subscribed'/>
          </pre>
<p>

</li>
<li>As a result, the user's server (1) MUST initiate a roster push to all of the user's available resources that have requested the roster, containing a roster item for the contact with the 'subscription' attribute set to a value of "both"; (2) MUST route the presence stanza of type "subscribed" to the contact, first stamping the 'from' address as the bare JID (&lt;user@somedomain&gt;) of the user; and (3) MUST send available presence from each of the user's available resources to the contact:
          </p>
<pre>
&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='contact@otherdomain'
        subscription='both'
        name='MyContact'>
      &lt;group>MyBuddies&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;presence
    from='user@somedomain'
    to='contact@otherdomain'
    type='subscribed'/>

&lt;presence
    from='user@somedomain/resource'
    to='contact@otherdomain'/>
          </pre>
<p>

</li>
<li>Upon receiving the presence stanza of type "subscribed" addressed to the contact, the contact's server MUST first verify that the user is in the contact's roster with either of the following states: (a) subscription='none' and ask='subscribe' or (b) subscription='from' and ask='subscribe'.  If the user is not in the contact's roster with either of those states, the contact's server MUST silently ignore the presence stanza of type "subscribed" (i.e., it MUST NOT route it to the contact, modify the contact's roster, or generate a roster push to the contact's available resources).  If the user is in the contact's roster with either of those states, the contact's server (1) MUST deliver the presence stanza of type "subscribed" from the user to the contact; (2) MUST initiate a roster push to all available resources associated with the contact that have requested the roster, containing an updated roster item for the user with the 'subscription' attribute set to a value of "both"; and (3) MUST deliver the available presence stanza received from each of the user's available resources to each of the contact's available resources:
          </p>
<pre>
&lt;presence
    from='user@somedomain'
    to='contact@otherdomain'
    type='subscribed'/>

&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='user@somedomain'
        subscription='both'
        name='SomeUser'>
      &lt;group>SomeGroup&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;presence
    from='user@somedomain/resource'
    to='contact@otherdomain/resource'/>
          </pre>
<p>

</li>
<li>Upon receiving the presence stanza of type "subscribed", the contact SHOULD acknowledge receipt of that subscription state notification through either "affirming" it by sending a presence stanza of type "subscribe" to the user or "denying" it by sending a presence stanza of type "unsubscribe" to the user; this step does not necessarily affect the subscription state (see <a href="#substates">Subscription States</a> for details), but instead lets the contact's server know that it MUST no longer send notification of the subscription state change to the contact (see <a href="#substates-ack">Section 9.6</a>).
</li>
</ol><p>
</p>
<p>The user and the contact now have a mutual subscription to each other's presence -- i.e., the subscription is of type "both".  The user's server MUST now send the user's current presence information to the contact.  (Note: If at this point the user sends a subscription request to the contact or the contact sends a subscription request to the user, the sending user's server MUST silently ignore that request and not route it to the intended recipient.)
</p>
<a name="rfc.section.8.3.1"></a><h4><a name="int-mutual-alt">8.3.1</a>&nbsp;Alternate Flow: User Declines Subscription Request</h4>

<p>The above activity flow represents the "happy path" related to the contact's subscription request to the user.  The main alternate flow occurs if the user refuses the contact's subscription request.
</p>
<p>
<ol class="text">
<li>If the user wants to refuse the request, the user's client MUST send a presence stanza of type "unsubscribed" to the contact (instead of the presence stanza of type "subscribed" sent in Step 3 of <a href="#int-mutual">Section 8.3</a>):
            </p>
<pre>
&lt;presence to='contact@otherdomain' type='unsubscribed'/>
            </pre>
<p>

</li>
<li>As a result, the user's server MUST route the presence stanza of type "unsubscribed" to the contact, first stamping the 'from' address as the bare JID (&lt;user@somedomain&gt;) of the user:
            </p>
<pre>
&lt;presence
    from='user@somedomain'
    to='contact@otherdomain'
    type='unsubscribed'/>
            </pre>
<p>

</li>
<li>Upon receiving the presence stanza of type "unsubscribed" addressed to the contact, the contact's server (1) MUST deliver that presence stanza to the contact; and (2) MUST initiate a roster push to all available resources associated with the contact that have requested the roster, containing an updated roster item for the user with the 'subscription' attribute set to a value of "from" and with no 'ask' attribute:
            </p>
<pre>
&lt;presence
    from='user@somedomain'
    to='contact@otherdomain'
    type='unsubscribed'/>

&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='user@somedomain'
        subscription='from'
        name='SomeUser'>
      &lt;group>SomeGroup&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>
            </pre>
<p>

</li>
<li>Upon receiving the presence stanza of type "unsubscribed", the contact SHOULD acknowledge receipt of that subscription state notification through either "affirming" it by sending a presence stanza of type "unsubscribe" to the user or "denying" it by sending a presence stanza of type "subscribe" to the user; this step does not necessarily affect the subscription state (see <a href="#substates">Subscription States</a> for details), but instead lets the contact's server know that it MUST no longer send notification of the subscription state change to the contact (see <a href="#substates-ack">Section 9.6</a>).
</li>
</ol><p>
</p>
<p>As a result of this activity, there has been no change in the subscription state; i.e., the contact is in the user's roster with a subscription state of "to" and the user is in the contact's roster with a subscription state of "from".
</p>
<a name="rfc.section.8.4"></a><h4><a name="int-unsub">8.4</a>&nbsp;Unsubscribing</h4>

<p>At any time after subscribing to a contact's presence, a user MAY unsubscribe.  While the XML that the user sends to make this happen is the same in all instances, the subsequent subscription state is different depending on the subscription state obtaining when the unsubscribe "command" is sent.  Both possible scenarios are defined below.
</p>
<a name="rfc.section.8.4.1"></a><h4><a name="anchor1">8.4.1</a>&nbsp;Case #1: Unsubscribing When Subscription is Not Mutual</h4>

<p>In the first case, the user has a subscription to the contact but the contact does not have a subscription to the user (i.e., the subscription is not yet mutual).
</p>
<p>
<ol class="text">
<li>If the user wants to unsubscribe from the contact's presence, the user MUST send a presence stanza of type "unsubscribe" to the contact:
            </p>
<pre>
&lt;presence to='contact@otherdomain' type='unsubscribe'/>
            </pre>
<p>

</li>
<li>As a result, the user's server (1) MUST send a roster push to all of the user's available resources that have requested the roster, containing an updated roster item for the contact with the 'subscription' attribute set to a value of "none"; and (2) MUST route the presence stanza of type "unsubscribe" to the contact, first stamping the 'from' address as the bare JID (&lt;user@somedomain&gt;) of the user:
            </p>
<pre>
&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='contact@otherdomain'
        subscription='none'
        name='MyContact'>
      &lt;group>MyBuddies&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;presence
    from='user@somedomain'
    to='contact@otherdomain'
    type='unsubscribe'/>
            </pre>
<p>

</li>
<li>Upon receiving the presence stanza of type "unsubscribe" addressed to the contact, the contact's server (1) MUST initiate a roster push to all available resources associated with the contact that have requested the roster, containing an updated roster item for the user with the 'subscription' attribute set to a value of "none" (if the contact is offline, the contact's server MUST modify the roster item and send that modified item the next time the contact requests the roster); and (2) MUST deliver the "unsubscribe" state change notification to the contact:
            </p>
<pre>
&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='user@somedomain'
        subscription='none'
        name='SomeUser'>
      &lt;group>SomeGroup&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;presence
    from='user@somedomain'
    to='contact@otherdomain'
    type='unsubscribe'/>
            </pre>
<p>

</li>
<li>Upon receiving the presence stanza of type "unsubscribe", the contact SHOULD acknowledge receipt of that subscription state notification through either "affirming" it by sending a presence stanza of type "unsubscribed" to the user or "denying" it by sending a presence stanza of type "subscribed" to the user; this step does not necessarily affect the subscription state (see <a href="#substates">Subscription States</a> for details), but instead lets the contact's server know that it MUST no longer send notification of the subscription state change to the contact (see <a href="#substates-ack">Section 9.6</a>).
</li>
<li>The contact's server then (1) MUST send a presence stanza of type "unsubscribed" to the user; and (2) SHOULD send unavailable presence from the contact to the user:
            </p>
<pre>
&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='unsubscribed'/>

&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='unavailable'/>
            </pre>
<p>

</li>
<li>When the user's server receives a presence stanza of type "unsubscribed" and/or unavailable presence, it MUST deliver them to the user:
            </p>
<pre>
&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='unsubscribed'/>

&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='unavailable'/>
            </pre>
<p>

</li>
<li>Upon receiving the presence stanza of type "unsubscribed", the user SHOULD acknowledge receipt of that subscription state notification through either "affirming" it by sending a presence stanza of type "unsubscribe" to the contact or "denying" it by sending a presence stanza of type "subscribe" to the contact; this step does not necessarily affect the subscription state (see <a href="#substates">Subscription States</a> for details), but instead lets the user's server know that it MUST no longer send notification of the subscription state change to the user (see <a href="#substates-ack">Section 9.6</a>).
</li>
</ol><p>
</p>
<a name="rfc.section.8.4.2"></a><h4><a name="anchor2">8.4.2</a>&nbsp;Case #2: Unsubscribing When Subscription is Mutual</h4>

<p>In the second case, the user has a subscription to the contact and the contact also has a subscription to the user (i.e., the subscription is mutual).
</p>
<p>
<ol class="text">
<li>If the user wants to unsubscribe from the contact's presence, the user MUST send a presence stanza of type "unsubscribe" to the contact:
            </p>
<pre>
&lt;presence to='contact@otherdomain' type='unsubscribe'/>
            </pre>
<p>

</li>
<li>As a result, the user's server (1) MUST send a roster push to all of the user's available resources that have requested the roster, containing an updated roster item for the contact with the 'subscription' attribute set to a value of "from"; and (2) MUST route the presence stanza of type "unsubscribe" to the contact, first stamping the 'from' address as the bare JID (&lt;user@somedomain&gt;) of the user:
            </p>
<pre>
&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='contact@otherdomain'
        subscription='from'
        name='MyContact'>
      &lt;group>MyBuddies&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;presence
    from='user@somedomain'
    to='contact@otherdomain'
    type='unsubscribe'/>
            </pre>
<p>

</li>
<li>Upon receiving the presence stanza of type "unsubscribe" addressed to the contact, the contact's server (1) MUST initiate a roster push to all available resources associated with the contact that have requested the roster, containing an updated roster item for the user with the 'subscription' attribute set to a value of "to" (if the contact is offline, the contact's server MUST modify the roster item and send that modified item the next time the contact requests the roster); and (2) MUST deliver the "unsubscribe" state change notification to the contact:
            </p>
<pre>
&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='user@somedomain'
        subscription='to'
        name='SomeUser'>
      &lt;group>SomeGroup&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;presence
    from='user@somedomain'
    to='contact@otherdomain'
    type='unsubscribe'/>
            </pre>
<p>

</li>
<li>Upon receiving the presence stanza of type "unsubscribe", the contact SHOULD acknowledge receipt of that subscription state notification through either "affirming" it by sending a presence stanza of type "unsubscribed" to the user or "denying" it by sending a presence stanza of type "subscribed" to the user; this step does not necessarily affect the subscription state (see <a href="#substates">Subscription States</a> for details), but instead lets the contact's server know that it MUST no longer send notification of the subscription state change to the contact (see <a href="#substates-ack">Section 9.6</a>).
</li>
<li>The contact's server then (1) MUST send a presence stanza of type "unsubscribed" to the user; and (2) SHOULD send unavailable presence from the contact to the user:
            </p>
<pre>
&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='unsubscribed'/>

&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='unavailable'/>
            </pre>
<p>

</li>
<li>When the user's server receives a presence stanza of type "unsubscribed" and/or unavailable presence, it MUST deliver them to the user:
            </p>
<pre>
&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='unsubscribed'/>

&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='unavailable'/>
            </pre>
<p>

</li>
<li>Upon receiving the presence stanza of type "unsubscribed", the user SHOULD acknowledge receipt of that subscription state notification through either "affirming" it by sending a presence stanza of type "unsubscribe" to the contact or "denying" it by sending a presence stanza of type "subscribe" to the contact; this step does not necessarily affect the subscription state (see <a href="#substates">Subscription States</a> for details), but instead lets the user's server know that it MUST no longer send notification of the subscription state change to the user (see <a href="#substates-ack">Section 9.6</a>).
</li>
</ol><p>
</p>
<p>Note: Obviously this does not result in removal of the roster item from the user's roster, and the contact still has a subscription to the user's presence.  In order to both completely cancel a mutual subscription and fully remove the roster item from the user's roster, the user SHOULD update the roster item with subscription='remove' as defined under <a href="#int-remove">Removing a Roster Item and Cancelling All Subscriptions</a>.
</p>
<a name="rfc.section.8.5"></a><h4><a name="int-cancel">8.5</a>&nbsp;Cancelling a Subscription</h4>

<p>At any time after approving a subscription request from a user, a contact MAY cancel that subscription.  While the XML that the contact sends to make this happen is the same in all instances, the subsequent subscription state is different depending on the subscription state obtaining when the cancellation was sent.  Both possible scenarios are defined below.
</p>
<a name="rfc.section.8.5.1"></a><h4><a name="anchor3">8.5.1</a>&nbsp;Case #1: Cancelling When Subscription is Not Mutual</h4>

<p>In the first case, the user has a subscription to the contact but the contact does not have a subscription to the user (i.e., the subscription is not yet mutual).
</p>
<p>
<ol class="text">
<li>If the contact wants to cancel the user's subscription, the contact MUST send a presence stanza of type "unsubscribed" to the user:
            </p>
<pre>
&lt;presence to='user@somedomain' type='unsubscribed'/>
            </pre>
<p>

</li>
<li>As a result, the contact's server (1) MUST send a roster push to all of the contact's available resources that have requested the roster, containing an updated roster item for the user with the 'subscription' attribute set to a value of "none"; (2) MUST route the presence stanza of type "unsubscribed" to the user, first stamping the 'from' address as the bare JID (&lt;contact@otherdomain&gt;) of the contact; and (3) SHOULD send unavailable presence from the contact to the user:
            </p>
<pre>
&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='user@somedomain'
        subscription='none'
        name='SomeUser'>
      &lt;group>SomeGroup&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='unsubscribed'/>

&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='unavailable'/>
            </pre>
<p>

</li>
<li>Upon receiving the presence stanza of type "unsubscribed" addressed to the user, the user's server (1) MUST initiate a roster push to all of the user's available resources that have requested the roster, containing an updated roster item for the contact with the 'subscription' attribute set to a value of "none" (if the user is offline, the user's server MUST modify the roster item and send that modified item the next time the user requests the roster); (2) MUST deliver the "unsubscribed" state change notification to the user; and (3) MUST deliver the unavailable presence to the user:
            </p>
<pre>
&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='contact@otherdomain'
        subscription='none'
        name='MyContact'>
      &lt;group>MyBuddies&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='unsubscribed'/>

&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='unavailable'/>
            </pre>
<p>

</li>
<li>Upon receiving the presence stanza of type "unsubscribed", the user SHOULD acknowledge receipt of that subscription state notification through either "affirming" it by sending a presence stanza of type "unsubscribe" to the contact or "denying" it by sending a presence stanza of type "subscribe" to the contact; this step does not necessarily affect the subscription state (see <a href="#substates">Subscription States</a> for details), but instead lets the user's server know that it MUST no longer send notification of the subscription state change to the user (see <a href="#substates-ack">Section 9.6</a>).
</li>
</ol><p>
</p>
<a name="rfc.section.8.5.2"></a><h4><a name="anchor4">8.5.2</a>&nbsp;Case #2: Cancelling When Subscription is Mutual</h4>

<p>In the second case, the user has a subscription to the contact and the contact also has a subscription to the user (i.e., the subscription is mutual).
</p>
<p>
<ol class="text">
<li>If the contact wants to cancel the user's subscription, the contact MUST send a presence stanza of type "unsubscribed" to the user:
            </p>
<pre>
&lt;presence to='user@somedomain' type='unsubscribed'/>
            </pre>
<p>

</li>
<li>As a result, the contact's server (1) MUST send a roster push to all of the contact's available resources that have requested the roster, containing an updated roster item for the user with the 'subscription' attribute set to a value of "to"; (2) MUST route the presence stanza of type "unsubscribed" to the user, first stamping the 'from' address as the bare JID (&lt;contact@otherdomain&gt;) of the contact; and (3) SHOULD send unavailable presence from the contact to the user:
            </p>
<pre>
&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='user@somedomain'
        subscription='to'
        name='SomeUser'>
      &lt;group>SomeGroup&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='unsubscribed'/>

&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='unavailable'/>
            </pre>
<p>

</li>
<li>Upon receiving the presence stanza of type "unsubscribed" addressed to the user, the user's server (1) MUST initiate a roster push to all of the user's available resources that have requested the roster, containing an updated roster item for the contact with the 'subscription' attribute set to a value of "from" (if the user is offline, the user's server MUST modify the roster item and send that modified item the next time the user requests the roster); and (2) MUST deliver the "unsubscribed" state change notification to the user; and (3) MUST deliver the unavailable presence to the user:
            </p>
<pre>
&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='contact@otherdomain'
        subscription='from'
        name='MyContact'>
      &lt;group>MyBuddies&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='unsubscribed'/>

&lt;presence
    from='contact@otherdomain'
    to='user@somedomain'
    type='unavailable'/>
            </pre>
<p>

</li>
<li>Upon receiving the presence stanza of type "unsubscribed", the user SHOULD acknowledge receipt of that subscription state notification through either "affirming" it by sending a presence stanza of type "unsubscribe" to the contact or "denying" it by sending a presence stanza of type "subscribe" to the contact; this step does not necessarily affect the subscription state (see <a href="#substates">Subscription States</a> for details), but instead lets the user's server know that it MUST no longer send notification of the subscription state change to the user (see <a href="#substates-ack">Section 9.6</a>).
</li>
</ol><p>
</p>
<p>Note: Obviously this does not result in removal of the roster item from the contact's roster, and the contact still has a subscription to the user's presence.  In order to both completely cancel a mutual subscription and fully remove the roster item from the contact's roster, the contact should update the roster item with subscription='remove' as defined under <a href="#int-remove">Removing a Roster Item and Cancelling All Subscriptions</a>.
</p>
<a name="rfc.section.8.6"></a><h4><a name="int-remove">8.6</a>&nbsp;Removing a Roster Item and Cancelling All Subscriptions</h4>

<p>Because there may be many steps involved in completely removing a roster item and cancelling subscriptions in both directions, the roster management protocol includes a "shortcut" method for doing so.  The process may be initiated no matter what the current subscription state is by sending a roster set containing an item for the contact with the 'subscription' attribute set to a value of "remove":
</p><pre>
&lt;iq type='set' id='remove1'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='contact@otherdomain'
        subscription='remove'/>
  &lt;/query>
&lt;/iq>
      </pre>

<p>When the user removes a contact from his or her roster by setting the 'subscription' attribute to a value of "remove", the user's server (1) MUST automatically cancel any existing presence subscription between the user and the contact (both 'to' and 'from' as appropriate); (2) MUST remove the roster item from the user's roster and inform all of the user's available resources of the roster item removal; (3) MUST inform the resource that initiated the removal of success; and (4) SHOULD send unavailable presence to the contact:
</p><pre>
&lt;presence
    from='user@somedomain'
    to='contact@otherdomain'
    type='unsubscribe'/>

&lt;presence
    from='user@somedomain'
    to='contact@otherdomain'
    type='unsubscribed'/>

&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='contact@otherdomain'
        subscription='remove'/>
  &lt;/query>
&lt;/iq>

&lt;iq type='result' id='remove1'/>

&lt;presence
    from='user@somedomain'
    to='contact@otherdomain'
    type='unavailable'/>
      </pre>

<p>Upon receiving the presence stanza of type "unsubscribe", the contact's server (1) MUST initiate a roster push to all available resources associated with the contact that have requested the roster, containing an updated roster item for the user with the 'subscription' attribute set to a value of "to" (if the contact is offline, the contact's server MUST modify the roster item and send that modified item the next time the contact requests the roster); and (2) MUST also deliver the "unsubscribe" state change notification to the contact:
</p><pre>
&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='user@somedomain'
        subscription='to'
        name='SomeUser'>
      &lt;group>SomeGroup&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;presence
    from='user@somedomain'
    to='contact@otherdomain'
    type='unsubscribe'/>
      </pre>

<p>Upon receiving the presence stanza of type "unsubscribed", the contact's server (1) MUST initiate a roster push to all available resources associated with the contact that have requested the roster, containing an updated roster item for the user with the 'subscription' attribute set to a value of "none" (if the contact is offline, the contact's server MUST modify the roster item and send that modified item the next time the contact requests the roster); and (2) MUST also deliver the "unsubscribe" state change notification to the contact:
</p><pre>
&lt;iq type='set'>
  &lt;query xmlns='jabber:iq:roster'>
    &lt;item
        jid='user@somedomain'
        subscription='none'
        name='SomeUser'>
      &lt;group>SomeGroup&lt;/group>
    &lt;/item>
  &lt;/query>
&lt;/iq>

&lt;presence
    from='user@somedomain'
    to='contact@otherdomain'
    type='unsubscribed'/>
      </pre>

<p>Upon receiving the presence stanza of type "unavailable" addressed to the contact, the contact's server MUST deliver the unavailable presence to the user:
</p><pre>
&lt;presence
    from='user@somedomain'
    to='contact@otherdomain'
    type='unavailable'/>
      </pre>

<p>Note that when the user removes the contact from the user's roster, the end state of the contact's roster is that the user is still in the contact's roster with a subscription state of "none"; in order to completely remove the roster item for the user, the contact needs to also send a roster removal request.
</p>
<a name="substates"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;Subscription States</h3>

<p>This section provides detailed information about subscription states.
</p>
<a name="rfc.section.9.1"></a><h4><a name="substates-defined">9.1</a>&nbsp;Defined States</h4>

<p>There are nine possible subscription states, which are described here from the user's perspective:
</p>
<p>
<ol class="text">
<li>"None" = contact and user are not subscribed to each other, and neither has requested a subscription from the other
</li>
<li>"None + Pending Out" = contact and user are not subscribed to each other, and user has sent contact a subscription request but contact has not responded yet
</li>
<li>"None + Pending In" = contact and user are not subscribed to each other, and contact has sent user a subscription request but user has not responded yet
</li>
<li>"None + Pending Out/In" = contact and user are not subscribed to each other, contact has sent user a subscription request but user has not responded yet, and user has sent contact a subscription request but contact has not responded yet
</li>
<li>"To" = user is subscribed to contact (one-way)
</li>
<li>"To + Pending In" = user is subscribed to contact, and contact has send user a subscription request but user has not responded yet
</li>
<li>"From" = contact is subscribed to user (one-way)
</li>
<li>"From + Pending Out" = contact is subscribed to user, and user has sent contact a subscription request but contact has not responded yet
</li>
<li>"Both" = user and contact are subscribed to each other (two-way)
</li>
</ol><p>
</p>
<a name="rfc.section.9.2"></a><h4><a name="substates-out-state">9.2</a>&nbsp;Server Handling of Outbound Presence, Categorized by Subscription State</h4>

<p>This section defines how a server MUST handle an outbound presence stanza of type "subscribe", "subscribed", "unsubscribe", or "unsubscribed" (i.e., route it to the intended recipient and/or make a change to the subscription state), categorized by the current subscription state.  The general rule is that a server MUST route the stanza to the intended recipient if it would change the subscription state, and MUST NOT route the stanza if it would not change the subscription state.  Detailed definitions are contained in the following sections.  Naturally, if the stanza changes the subscription state, the server MUST change the subscription state in addition to routing the subscription state.
</p>
<a name="rfc.section.9.2.1"></a><h4><a name="substates-out-state-none">9.2.1</a>&nbsp;Subscription State = None</h4>
<pre>
+-------------------------------------------------------+
|  STANZA TYPE   |  ROUTE?  |  NEW STATE                |
+-------------------------------------------------------+
|  subscribe     |  yes     |  "None + Pending Out"     |
|  subscribed    |  no      |  no state change          |
|  unsubscribe   |  no      |  no state change          |
|  unsubscribed  |  no      |  no state change          |
+-------------------------------------------------------+
        </pre>

<a name="rfc.section.9.2.2"></a><h4><a name="substates-out-state-none-out">9.2.2</a>&nbsp;Subscription State = None + Pending Out</h4>
<pre>
+-------------------------------------------------------+
|  STANZA TYPE   |  ROUTE?  |  NEW STATE                |
+-------------------------------------------------------+
|  subscribe     |  no      |  no state change          |
|  subscribed    |  no      |  no state change          |
|  unsubscribe   |  yes     |  "None"                   |
|  unsubscribed  |  no      |  no state change          |
+-------------------------------------------------------+
        </pre>

<a name="rfc.section.9.2.3"></a><h4><a name="substates-out-state-none-in">9.2.3</a>&nbsp;Subscription State = None + Pending In</h4>
<pre>
+-------------------------------------------------------+
|  STANZA TYPE   |  ROUTE?  |  NEW STATE                |
+-------------------------------------------------------+
|  subscribe     |  yes     |  "None + Pending Out/In"  |
|  subscribed    |  yes     |  "From"                   |
|  unsubscribe   |  no      |  no state change          |
|  unsubscribed  |  yes     |  "None"                   |
+-------------------------------------------------------+
        </pre>

<a name="rfc.section.9.2.4"></a><h4><a name="substates-out-state-none-outin">9.2.4</a>&nbsp;Subscription State = None + Pending Out/In</h4>
<pre>
+-------------------------------------------------------+
|  STANZA TYPE   |  ROUTE?  |  NEW STATE                |
+-------------------------------------------------------+
|  subscribe     |  no      |  no state change          |
|  subscribed    |  yes     |  "From + Pending Out"     |
|  unsubscribe   |  yes     |  "None + Pending In"      |
|  unsubscribed  |  yes     |  "None + Pending Out"     |
+-------------------------------------------------------+
        </pre>

<a name="rfc.section.9.2.5"></a><h4><a name="substates-out-state-to">9.2.5</a>&nbsp;Subscription State = To</h4>
<pre>
+-------------------------------------------------------+
|  STANZA TYPE   |  ROUTE?  |  NEW STATE                |
+-------------------------------------------------------+
|  subscribe     |  no      |  no state change          |
|  subscribed    |  no      |  no state change          |
|  unsubscribe   |  yes     |  "None"                   |
|  unsubscribed  |  no      |  no state change          |
+-------------------------------------------------------+
        </pre>

<a name="rfc.section.9.2.6"></a><h4><a name="substates-out-state-to-in">9.2.6</a>&nbsp;Subscription State = To + Pending In</h4>
<pre>
+-------------------------------------------------------+
|  STANZA TYPE   |  ROUTE?  |  NEW STATE                |
+-------------------------------------------------------+
|  subscribe     |  no      |  no state change          |
|  subscribed    |  yes     |  "Both"                   |
|  unsubscribe   |  yes     |  "None + Pending In"      |
|  unsubscribed  |  yes     |  "To"                     |
+-------------------------------------------------------+
        </pre>

<a name="rfc.section.9.2.7"></a><h4><a name="substates-out-state-from">9.2.7</a>&nbsp;Subscription State = From</h4>
<pre>
+-------------------------------------------------------+
|  STANZA TYPE   |  ROUTE?  |  NEW STATE                |
+-------------------------------------------------------+
|  subscribe     |  yes     |  "From + Pending Out"     |
|  subscribed    |  no      |  no state change          |
|  unsubscribe   |  no      |  no state change          |
|  unsubscribed  |  yes     |  "None"                   |
+-------------------------------------------------------+
        </pre>

<a name="rfc.section.9.2.8"></a><h4><a name="substates-out-state-from-out">9.2.8</a>&nbsp;Subscription State = From + Pending Out</h4>
<pre>
+-------------------------------------------------------+
|  STANZA TYPE   |  ROUTE?  |  NEW STATE                |
+-------------------------------------------------------+
|  subscribe     |  no      |  no state change          |
|  subscribed    |  no      |  no state change          |
|  unsubscribe   |  yes     |  "From"                   |
|  unsubscribed  |  yes     |  "None + Pending Out"     |
+-------------------------------------------------------+
        </pre>

<a name="rfc.section.9.2.9"></a><h4><a name="substates-out-state-both">9.2.9</a>&nbsp;Subscription State = Both</h4>
<pre>
+-------------------------------------------------------+
|  STANZA TYPE   |  ROUTE?  |  NEW STATE                |
+-------------------------------------------------------+
|  subscribe     |  no      |  no state change          |
|  subscribed    |  no      |  no state change          |
|  unsubscribe   |  yes     |  "From"                   |
|  unsubscribed  |  yes     |  "To"                     |
+-------------------------------------------------------+
        </pre>

<a name="rfc.section.9.3"></a><h4><a name="substates-out-type">9.3</a>&nbsp;Server Handling of Outbound Presence, Categorized by Presence Type</h4>

<p>This section defines how a server MUST handle an outbound presence stanza of type "subscribe", "subscribed", "unsubscribe", or "unsubscribed" (i.e., route it to the intended recipient and/or make a change to the subscription state), categorized by presence type.
</p>
<a name="rfc.section.9.3.1"></a><h4><a name="substates-out-type-subscribe">9.3.1</a>&nbsp;Subscribe</h4>
<pre>
+----------------------------------------------------------------+
|  EXISTING STATE          |  ROUTE?  |  NEW STATE               |
+----------------------------------------------------------------+
|  "None"                  |  yes     |  "None + Pending Out"    |
|  "None + Pending Out"    |  no      |  no state change         |
|  "None + Pending In"     |  yes     |  "None + Pending Out/In" |
|  "None + Pending Out/In" |  no      |  no state change         |
|  "To"                    |  no      |  no state change         |
|  "To + Pending In"       |  no      |  no state change         |
|  "From"                  |  yes     |  "From + Pending Out"    |
|  "From + Pending Out"    |  no      |  no state change         |
|  "Both"                  |  no      |  no state change         |
+----------------------------------------------------------------+
        </pre>

<a name="rfc.section.9.3.2"></a><h4><a name="substates-out-type-subscribed">9.3.2</a>&nbsp;Subscribed</h4>
<pre>
+----------------------------------------------------------------+
|  EXISTING STATE          |  ROUTE?  |  NEW STATE               |
+----------------------------------------------------------------+
|  "None"                  |  no      |  no state change         |
|  "None + Pending Out"    |  no      |  no state change         |
|  "None + Pending In"     |  yes     |  "From"                  |
|  "None + Pending Out/In" |  yes     |  "From + Pending Out"    |
|  "To"                    |  no      |  no state change         |
|  "To + Pending In"       |  yes     |  "Both"                  |
|  "From"                  |  no      |  no state change         |
|  "From + Pending Out"    |  no      |  no state change         |
|  "Both"                  |  no      |  no state change         |
+----------------------------------------------------------------+
        </pre>

<a name="rfc.section.9.3.3"></a><h4><a name="substates-out-type-unsubscribe">9.3.3</a>&nbsp;Unsubscribe</h4>
<pre>
+----------------------------------------------------------------+
|  EXISTING STATE          |  ROUTE?  |  NEW STATE               |
+----------------------------------------------------------------+
|  "None"                  |  no      |  no state change         |
|  "None + Pending Out"    |  yes     |  "None"                  |
|  "None + Pending In"     |  no      |  no state change         |
|  "None + Pending Out/In" |  yes     |  "None + Pending In"     |
|  "To"                    |  yes     |  "None"                  |
|  "To + Pending In"       |  yes     |  "None + Pending In"     |
|  "From"                  |  no      |  no state change         |
|  "From + Pending Out"    |  yes     |  "From"                  |
|  "Both"                  |  yes     |  "From"                  |
+----------------------------------------------------------------+
        </pre>

<p>Note: When a user sends an outbound presence stanza of type "unsubscribe" that results in a subscription state change, the contact's server SHOULD auto-reply by sending a presence stanza of type "unsubscribed" to the user on behalf of the contact and MUST deliver that presence stanza to the contact.
</p>
<a name="rfc.section.9.3.4"></a><h4><a name="substates-out-type-unsubscribed">9.3.4</a>&nbsp;Unsubscribed</h4>
<pre>
+----------------------------------------------------------------+
|  EXISTING STATE          |  ROUTE?  |  NEW STATE               |
+----------------------------------------------------------------+
|  "None"                  |  no      |  no state change         |
|  "None + Pending Out"    |  no      |  no state change         |
|  "None + Pending In"     |  yes     |  "None"                  |
|  "None + Pending Out/In" |  yes     |  "None + Pending Out"    |
|  "To"                    |  no      |  no state change         |
|  "To + Pending In"       |  yes     |  "To"                    |
|  "From"                  |  yes     |  "None"                  |
|  "From + Pending Out"    |  yes     |  "None + Pending Out"    |
|  "Both"                  |  yes     |  "To"                    |
+----------------------------------------------------------------+
        </pre>

<a name="rfc.section.9.4"></a><h4><a name="substates-in-state">9.4</a>&nbsp;Server Handling of Inbound Presence, Categorized by Subscription State</h4>

<p>This section defines how a server MUST handle an inbound presence stanza of type "subscribe", "subscribed", "unsubscribe", or "unsubscribed" (i.e., deliver it to the intended recipient and/or make a change to the subscription state), categorized by subscription state.  (Note: some of the presence stanza types should never be received as inbound stanzas, since the sender's server MUST NOT route them to the intended recipient; however, these stanza types are included for the sake of completeness.)
</p>
<a name="rfc.section.9.4.1"></a><h4><a name="substates-in-state-none">9.4.1</a>&nbsp;Subscription State = None</h4>
<pre>
+--------------------------------------------------------+
|  STANZA TYPE   |  DELIVER?  |  NEW STATE               |
+--------------------------------------------------------+
|  subscribe     |  yes       |  "None + Pending In"     |
|  subscribed    |  no        |  no state change         |
|  unsubscribe   |  no        |  no state change         |
|  unsubscribed  |  no        |  no state change         |
+--------------------------------------------------------+
        </pre>

<a name="rfc.section.9.4.2"></a><h4><a name="substates-in-state-none-out">9.4.2</a>&nbsp;Subscription State = None + Pending Out</h4>
<pre>
+--------------------------------------------------------+
|  STANZA TYPE   |  DELIVER?  |  NEW STATE               |
+--------------------------------------------------------+
|  subscribe     |  yes       |  "None + Pending Out/In" |
|  subscribed    |  yes       |  "To"                    |
|  unsubscribe   |  no        |  no state change         |
|  unsubscribed  |  yes       |  "None"                  |
+--------------------------------------------------------+
        </pre>

<a name="rfc.section.9.4.3"></a><h4><a name="substates-in-state-none-in">9.4.3</a>&nbsp;Subscription State = None + Pending In</h4>
<pre>
+--------------------------------------------------------+
|  STANZA TYPE   |  DELIVER?  |  NEW STATE               |
+--------------------------------------------------------+
|  subscribe     |  no        |  no state change         |
|  subscribed    |  no        |  no state change         |
|  unsubscribe   |  yes       |  "None"                  |
|  unsubscribed  |  no        |  no state change         |
+--------------------------------------------------------+
        </pre>

<a name="rfc.section.9.4.4"></a><h4><a name="substates-in-state-none-outin">9.4.4</a>&nbsp;Subscription State = None + Pending Out/In</h4>
<pre>
+--------------------------------------------------------+
|  STANZA TYPE   |  DELIVER?  |  NEW STATE               |
+--------------------------------------------------------+
|  subscribe     |  no        |  no state change         |
|  subscribed    |  yes       |  "To + Pending In"       |
|  unsubscribe   |  yes       |  "None + Pending Out"    |
|  unsubscribed  |  yes       |  "None + Pending In"     |
+--------------------------------------------------------+
        </pre>

<a name="rfc.section.9.4.5"></a><h4><a name="substates-in-state-to">9.4.5</a>&nbsp;Subscription State = To</h4>
<pre>
+--------------------------------------------------------+
|  STANZA TYPE   |  DELIVER?  |  NEW STATE               |
+--------------------------------------------------------+
|  subscribe     |  yes       |  "To + Pending In"       |
|  subscribed    |  no        |  no state change         |
|  unsubscribe   |  no        |  no state change         |
|  unsubscribed  |  yes       |  "None"                  |
+--------------------------------------------------------+
        </pre>

<a name="rfc.section.9.4.6"></a><h4><a name="substates-in-state-to-in">9.4.6</a>&nbsp;Subscription State = To + Pending In</h4>
<pre>
+--------------------------------------------------------+
|  STANZA TYPE   |  DELIVER?  |  NEW STATE               |
+--------------------------------------------------------+
|  subscribe     |  no        |  no state change         |
|  subscribed    |  no        |  no state change         |
|  unsubscribe   |  yes       |  "To"                    |
|  unsubscribed  |  yes       |  "None + Pending In"     |
+--------------------------------------------------------+
        </pre>

<a name="rfc.section.9.4.7"></a><h4><a name="substates-in-state-from">9.4.7</a>&nbsp;Subscription State = From</h4>
<pre>
+--------------------------------------------------------+
|  STANZA TYPE   |  DELIVER?  |  NEW STATE               |
+--------------------------------------------------------+
|  subscribe     |  no        |  no state change         |
|  subscribed    |  no        |  no state change         |
|  unsubscribe   |  yes       |  "None"                  |
|  unsubscribed  |  no        |  no state change         |
+--------------------------------------------------------+
        </pre>

<a name="rfc.section.9.4.8"></a><h4><a name="substates-in-state-from-out">9.4.8</a>&nbsp;Subscription State = From + Pending Out</h4>
<pre>
+--------------------------------------------------------+
|  STANZA TYPE   |  DELIVER?  |  NEW STATE               |
+--------------------------------------------------------+
|  subscribe     |  no        |  no state change         |
|  subscribed    |  yes       |  "Both"                  |
|  unsubscribe   |  yes       |  "None + Pending Out"    |
|  unsubscribed  |  yes       |  "From"                  |
+--------------------------------------------------------+
        </pre>

<a name="rfc.section.9.4.9"></a><h4><a name="substates-in-state-both">9.4.9</a>&nbsp;Subscription State = Both</h4>
<pre>
+--------------------------------------------------------+
|  STANZA TYPE   |  DELIVER?  |  NEW STATE               |
+--------------------------------------------------------+
|  subscribe     |  no        |  no state change         |
|  subscribed    |  no        |  no state change         |
|  unsubscribe   |  yes       |  "To"                    |
|  unsubscribed  |  yes       |  "From"                  |
+--------------------------------------------------------+
        </pre>

<a name="rfc.section.9.5"></a><h4><a name="substates-in-type">9.5</a>&nbsp;Server Handling of Inbound Presence, Categorized by Presence Type</h4>

<p>This section defines how a server MUST handle an inbound presence stanza of type "subscribe", "subscribed", "unsubscribe", or "unsubscribed" (i.e., deliver it to the intended recipient and/or make a change to the subscription state), categorized by presence type.
</p>
<a name="rfc.section.9.5.1"></a><h4><a name="substates-in-type-subscribe">9.5.1</a>&nbsp;Subscribe</h4>
<pre>
+------------------------------------------------------------------+
|  EXISTING STATE          |  DELIVER?  |  NEW STATE               |
+------------------------------------------------------------------+
|  "None"                  |  yes       |  "None + Pending In"     |
|  "None + Pending Out"    |  yes       |  "None + Pending Out/In" |
|  "None + Pending In"     |  no        |  no state change         |
|  "None + Pending Out/In" |  no        |  no state change         |
|  "To"                    |  yes       |  "To + Pending In"       |
|  "To + Pending In"       |  no        |  no state change         |
|  "From"                  |  no        |  no state change         |
|  "From + Pending Out"    |  no        |  no state change         |
|  "Both"                  |  no        |  no state change         |
+------------------------------------------------------------------+
        </pre>

<a name="rfc.section.9.5.2"></a><h4><a name="substates-in-type-subscribed">9.5.2</a>&nbsp;Subscribed</h4>
<pre>
+------------------------------------------------------------------+
|  EXISTING STATE          |  DELIVER?  |  NEW STATE               |
+------------------------------------------------------------------+
|  "None"                  |  no        |  no state change         |
|  "None + Pending Out"    |  yes       |  "To"                    |
|  "None + Pending In"     |  no        |  no state change         |
|  "None + Pending Out/In" |  yes       |  "To + Pending In"       |
|  "To"                    |  no        |  no state change         |
|  "To + Pending In"       |  no        |  no state change         |
|  "From"                  |  no        |  no state change         |
|  "From + Pending Out"    |  yes       |  "Both"                  |
|  "Both"                  |  no        |  no state change         |
+------------------------------------------------------------------+
        </pre>

<a name="rfc.section.9.5.3"></a><h4><a name="substates-in-type-unsubscribe">9.5.3</a>&nbsp;Unsubscribe</h4>
<pre>
+------------------------------------------------------------------+
|  EXISTING STATE          |  DELIVER?  |  NEW STATE               |
+------------------------------------------------------------------+
|  "None"                  |  no        |  no state change         |
|  "None + Pending Out"    |  no        |  no state change         |
|  "None + Pending In"     |  yes       |  "None"                  |
|  "None + Pending Out/In" |  yes       |  "None + Pending Out"    |
|  "To"                    |  no        |  no state change         |
|  "To + Pending In"       |  yes       |  "To"                    |
|  "From"                  |  yes       |  "None"                  |
|  "From + Pending Out"    |  yes       |  "None + Pending Out     |
|  "Both"                  |  yes       |  "To"                    |
+------------------------------------------------------------------+
        </pre>

<a name="rfc.section.9.5.4"></a><h4><a name="substates-in-type-unsubscribed">9.5.4</a>&nbsp;Unsubscribed</h4>
<pre>
+------------------------------------------------------------------+
|  EXISTING STATE          |  DELIVER?  |  NEW STATE               |
+------------------------------------------------------------------+
|  "None"                  |  no        |  no state change         |
|  "None + Pending Out"    |  yes       |  "None"                  |
|  "None + Pending In"     |  no        |  no state change         |
|  "None + Pending Out/In" |  yes       |  "None + Pending In"     |
|  "To"                    |  yes       |  "None"                  |
|  "To + Pending In"       |  yes       |  "None + Pending In"     |
|  "From"                  |  no        |  no state change         |
|  "From + Pending Out"    |  yes       |  "From"                  |
|  "Both"                  |  yes       |  "From"                  |
+------------------------------------------------------------------+
        </pre>

<a name="rfc.section.9.6"></a><h4><a name="substates-ack">9.6</a>&nbsp;Server Delivery and Client Acknowledgement of Subscription State Change Notifications</h4>

<p>When a server receives an inbound presence stanza of type "subscribe", "subscribed", "unsubscribe", or "unsubscribed" that consists of a subscription state change notification, in addition to sending the appropriate roster push (or updated roster when the roster is next requested), it MUST deliver the notification to the intended recipient at least once.  A server MAY require the recipient to acknowledge receipt of the all state change notifications (and MUST require acknowledgement in the case of subscription requests, i.e., presence stanzas of type "subscribe").  In order to require acknowledgement, a server SHOULD send the notification to the recipient each time the recipient logs in, until the recipient acknowledges receipt of the notification by "affirming" or "denying" the notification, as shown in the following table:
</p><pre>
+--------------------------------------------------+
|  NOTIFICATION  |  ACCEPT        |  DENY          |
+--------------------------------------------------+
|  subscribe     |  subscribed    |  unsubscribed  |
|  subscribed    |  subscribe     |  unsubscribe   |
|  unsubscribe   |  unsubscribed  |  subscribed    |
|  unsubscribed  |  unsubscribe   |  subscribe     |
+--------------------------------------------------+
        </pre>

<p>Obviously, given the foregoing subscription state charts, some of the acknowledgement stanzas will be routed to the contact and result in subscription state changes, while others will not.  However, any such stanzas MUST result in the server's no longer sending the subscription state notification to the user.
</p>
<p>Because a user's server MUST automatically generate outbound presence stanzas of type "unsubscribe" and "unsubscribed" upon receiving a roster set with the 'subscription' attribute set to a value of "remove" (see <a href="#int-remove">Removing a Roster Item and Cancelling All Subscriptions</a>) the server MUST treat a roster remove request as equivalent to sending those presence stanzas for purposes of determining whether to continue sending subscription state change notifications of type "subscribe" or "subscribed" to the user.
</p>
<a name="privacy"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;Blocking Communication</h3>

<p>Most instant messaging systems have found it necessary to implement some method for users to block communications from particular other users (this is also required by sections 5.1.5, 5.1.15, 5.3.2, and 5.4.10 of <a href="#IMP-REQS" title="Day, M., Aggarwal, S. and J. Vincent, Instant Messaging / Presence Protocol Requirements, February 2000.">[IMP-REQS]</a>).  In XMPP this is done using the 'jabber:iq:privacy' namespace by managing one's privacy lists.
</p>
<p>Server-side privacy lists enable successful completion of the following use cases:
</p>
<p>
<ul class="text">
<li>Retrieving one's privacy lists.
</li>
<li>Adding, removing, and editing one's privacy lists.
</li>
<li>Setting, changing, or declining active lists.
</li>
<li>Setting, changing, or declining the default list (i.e., the list that is active by default).
</li>
<li>Allowing or blocking messages based on JID, group, or subscription type (or globally).
</li>
<li>Allowing or blocking inbound presence notifications based on JID, group, or subscription type (or globally).
</li>
<li>Allowing or blocking outbound presence notifications based on JID, group, or subscription type (or globally).
</li>
<li>Allowing or blocking IQs based on JID, group, or subscription type (or globally).
</li>
<li>Allowing or blocking all communications based on JID, group, or subscription type (or globally).
</li>
</ul><p>
</p>
<p>Note: presence notifications do not include presence subscriptions, only presence information that is broadcasted to entities that are subscribed to a user's presence information.  Thus this includes presence stanzas with no 'type' attribute or of type='unavailable' only.
</p>
<a name="rfc.section.10.1"></a><h4><a name="privacy-syntax">10.1</a>&nbsp;Syntax and Semantics</h4>

<p>A user MAY define one or more privacy lists, which are stored by the user's server.  Each &lt;list/&gt; element contains one or more rules in the form of &lt;item/&gt; elements, and each &lt;item/&gt; element uses attributes to define a privacy rule type, a specific value to which the rules applies, the relevant action, and the place of the item in the processing order.
</p>
<p>The syntax is as follows:
</p><pre>
&lt;iq>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='foo'>
      &lt;item
          type='[jid|group|subscription]'
          value='bar'
          action='[allow|deny]'
          order='unsignedInt'>
        [&lt;message/>]
        [&lt;presence-in/>]
        [&lt;presence-out/>]
        [&lt;iq/>]
      &lt;/item>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>If the type is "jid", then the 'value' attribute MUST contain a valid Jabber ID.  JIDs are matched in the following order: &lt;user@domain/resource&gt;, then &lt;user@domain&gt;, then &lt;domain/resource&gt;, then &lt;domain&gt;.  If the value is &lt;user@domain&gt;, then any connected resource for that user@domain matches.  If the value is &lt;domain/resource&gt;, then only that resource matches.  If the value is &lt;domain&gt;, then any user@domain (or subdomain) matches.
</p>
<p>If the type is "group", then the 'value' attribute SHOULD contain the name of a group in the user's roster.  (If a client attempts to update, create, or delete a list item with a group that is not in the user's roster, the server SHOULD return to the client an &lt;item-not-found/&gt; stanza error.)
</p>
<p>If the type is "subscription", then the 'value' attribute MUST be one of "both", "to", "from", or "none" as defined under <a href="#roster-syntax">Roster Syntax and Semantics</a>.
</p>
<p>If no 'type' attribute is included, the rule provides the "fall-through" case.
</p>
<p>The 'action' attribute MUST be included and its value MUST be either "accept" or "deny".
</p>
<p>The 'order' attribute MUST be included and its value MUST be a non-negative integer that is unique among all items in the list.  (If a client attempts to create or update a list with non-unique order values, the server MUST return to the client a &lt;bad-request/&gt; stanza error.)
</p>
<p>The &lt;item/&gt; element MAY contain one or more child elements that enable an entity to specify more granular control over which kinds of stanzas are to be blocked (i.e., rather than blocking all stanzas).  The allowable child elements are:
</p>
<p>
<ul class="text">
<li>&lt;message/&gt; -- blocks incoming message stanzas
</li>
<li>&lt;iq/&gt; -- blocks incoming IQ stanzas
</li>
<li>&lt;presence-in/&gt; -- blocks incoming presence notifications
</li>
<li>&lt;presence-out/&gt; -- blocks outgoing presence notifications
</li>
</ul><p>
</p>
<p>Within the 'jabber:iq:privacy' namespace, the &lt;query/&gt; child of a client-generated IQ stanza of type "set" MUST NOT include more than one child element (i.e., the stanza must contain only one &lt;active/&gt; element, one &lt;default/&gt; element, or one &lt;list/&gt; element); if a client violates this rule, the server MUST return to the client a &lt;bad-request/&gt; stanza error.
</p>
<p>When a client adds or updates a privacy list, the &lt;list/&gt; element SHOULD contain at least one &lt;item/&gt; child element; when a client removes a privacy list, the &lt;list/&gt; element SHOULD contain no &lt;item/&gt; child element.
</p>
<p>When a client updates a privacy list, it must include all of the desired items (i.e., not a "delta").
</p>
<a name="rfc.section.10.2"></a><h4><a name="privacy-rules">10.2</a>&nbsp;Business Rules</h4>

<p>
<ol class="text">
<li>If there is an active list set for a session, it affects only the session for which it is activated, and only for the duration of the session.  The server MUST apply the active list only and MUST NOT apply the default list.
</li>
<li>The default list applies to the user as a whole, and is processed if there is no active list set for the target session/resource to which a stanza is addressed, or if there are no current sessions for the user.
</li>
<li>If there is no active list set for a session (or there are no current sessions for the user), and there is no default list, then all stanzas SHOULD BE accepted or appropriately processed by the server on behalf of the user.
</li>
<li>Privacy lists MUST be the first rule applied by a server, superseding (1) the routing and delivery rules specified in <a href="#rules">Server Rules for Handling XML Stanzas</a>, and (2) the handling of subscription-related presence stanzas (and corresponding generation of roster pushes) specified in <a href="#int">Integration of Roster Items and Presence Subscriptions</a>.
</li>
<li>The order in which privacy list items are processed by the server is important.  List items MUST be processed in ascending order determined by the integer values of the 'order' attribute for each &lt;item/&gt;.
</li>
<li>As soon as a stanza is matched against a privacy list, the server SHOULD appropriately handle the stanza and cease processing.
</li>
<li>If no fall-through item is provided in a list, the fall-through action is assumed to be "accept".
</li>
<li>If a user updates the definition for an active list, subsequent processing based on that active list MUST use the updated definition (for all resources to which that active list currently applies).
</li>
<li>If a change to the subscription state or roster group of a roster item defined in an active or default list occurs during a user's session, subsequent processing based on that list MUST take into account the changed state or group (for all resources to which that list currently applies).
</li>
</ol><p>
</p>
<a name="rfc.section.10.3"></a><h4><a name="privacy-retrieve">10.3</a>&nbsp;Retrieving One's Privacy Lists</h4>

<p>Example: Client requests names of privacy lists from server:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='get' id='getlist1'>
  &lt;query xmlns='jabber:iq:privacy'/>
&lt;/iq>
        </pre>

<p>Example: Server sends names of privacy lists to client, preceded by active list and default list:
</p><pre>
&lt;iq type='result' id='getlist1' to='romeo@example.net/orchard'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;active name='private'/>
    &lt;default name='public'/>
    &lt;list name='public'/>
    &lt;list name='private'/>
    &lt;list name='special'/>
  &lt;/query>
&lt;/iq>
        </pre>

<p>Example: Client requests a privacy list from server:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='get' id='getlist2'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='public'/>
  &lt;/query>
&lt;/iq>
        </pre>

<p>Example: Server sends a privacy list to client:
</p><pre>
&lt;iq type='result' id='getlist2' to='romeo@example.net/orchard'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='public'>
      &lt;item type='jid'
            value='tybalt@example.com'
            action='deny'
            order='1'/>
      &lt;item action='allow' order='2'/>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>Example: Client requests another privacy list from server:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='get' id='getlist3'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='private'/>
  &lt;/query>
&lt;/iq>
        </pre>

<p>Example: Server sends another privacy list to client:
</p><pre>
&lt;iq type='result' id='getlist3' to='romeo@example.net/orchard'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='private'>
      &lt;item type='subscription'
            value='both'
            action='allow'
            order='10'/>
      &lt;item action='deny' order='15'/>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>Example: Client requests yet another privacy list from server:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='get' id='getlist4'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='special'/>
  &lt;/query>
&lt;/iq>
        </pre>

<p>Example: Server sends yet another privacy list to client:
</p><pre>
&lt;iq type='result' id='getlist4' to='romeo@example.net/orchard'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='special'>
      &lt;item type='jid'
            value='juliet@example.com'
            action='allow'
            order='6'/>
      &lt;item type='jid'
            value='benvolio@example.org'
            action='allow'
            order='7'/>
      &lt;item type='jid'
            value='mercutio@example.org'
            action='allow'
            order='42'/>
      &lt;item action='deny' order='666'/>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>In this example, the user has three lists: (1) 'public', which allows communications from everyone except one specific entity (this is the default list); (2) 'private', which allows communications only with contacts who have a bidirectional subscription with the user (this is the active list); and (3) 'special', which allows communications only with three specific entities.
</p>
<p>If the user attempts to retrieve a list but a list by that name does not exist, the server MUST return an &lt;item-not-found/&gt; stanza error to the user:
</p>
<p>Example: Client attempts to retrieve non-existent list:
</p><pre>
&lt;iq to='romeo@example.org/orchard' type='error' id='getlist5'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='The Empty Set'/>
  &lt;/query>
  &lt;error type='cancel'>
    &lt;item-not-found
        xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
  &lt;/error>
&lt;/iq>
        </pre>

<p>The user is allowed to retrieve only one list at a time.  If the user attempts to retrieve more than one list in the same request, the server MUST return a &lt;bad request/&gt; stanza error to the user:
</p>
<p>Example: Client attempts to retrieve more than one list:
</p><pre>
&lt;iq to='romeo@example.org/orchard' type='error' id='getlist6'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='public'/>
    &lt;list name='private'/>
    &lt;list name='special'/>
  &lt;/query>
  &lt;error type='modify'>
    &lt;bad-request
        xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
  &lt;/error>
&lt;/iq>
        </pre>

<a name="rfc.section.10.4"></a><h4><a name="privacy-active">10.4</a>&nbsp;Managing Active Lists</h4>

<p>In order to set or change the active list currently being applied by the server, the user MUST send an IQ stanza of type "set" with a &lt;query/&gt; element qualified by the 'jabber:iq:privacy' namespace that contains an empty &lt;active/&gt; child element possessing a 'name' attribute whose value is set to the desired list name.
</p>
<p>Example: Client requests change of active list:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='active1'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;active name='special'/>
  &lt;/query>
&lt;/iq>
        </pre>

<p>The server MUST activate and apply the requested list before sending the result back to the client.
</p>
<p>Example: Server acknowledges success of active list change:
</p><pre>
&lt;iq type='result' id='active1' to='juliet@example.com/balcony'/>
        </pre>

<p>If the user attempts to set an active list but a list by that name does not exist, the server MUST return an &lt;item-not-found/&gt; stanza error to the user:
</p>
<p>Example: Client attempts to set a non-existent list as active:
</p><pre>
&lt;iq to='romeo@example.org/orchard' type='error' id='active2'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;active name='The Empty Set'/>
  &lt;/query>
  &lt;error type='cancel'>
    &lt;item-not-found
        xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
  &lt;/error>
&lt;/iq>
        </pre>

<p>In order to decline the use of any active list, the user MUST send an empty &lt;active/&gt; element with no name.
</p>
<p>Example: Client declines the use of active lists:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='active2'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;active/>
  &lt;/query>
&lt;/iq>
        </pre>

<a name="rfc.section.10.5"></a><h4><a name="privacy-default">10.5</a>&nbsp;Managing the Default List</h4>

<p>In order to change its default list, the user MUST send an IQ stanza of type "set" with a &lt;query/&gt; element qualified by the 'jabber:iq:privacy' namespace that contains an empty &lt;default/&gt; child element possessing a 'name' attribute whose value is set to the desired list name.
</p>
<p>Example: Client requests change of default list:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='default1'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;default name='special'/>
  &lt;/query>
&lt;/iq>
        </pre>

<p>Example: Server acknowledges success of default list change:
</p><pre>
&lt;iq type='result' id='default1' to='juliet@example.com/balcony'/>
        </pre>

<p>If the user attempts to set a default list but a list by that name does not exist, the server MUST return an &lt;item-not-found/&gt; stanza error to the user:
</p>
<p>Example: Client attempts to set a non-existent list as default:
</p><pre>
&lt;iq to='romeo@example.org/orchard' type='error' id='default2'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;default name='The Empty Set'/>
  &lt;/query>
  &lt;error type='cancel'>
    &lt;item-not-found
        xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
  &lt;/error>
&lt;/iq>
        </pre>

<p>In order to decline the use of a default list (i.e., to use the domain's stanza routing rules at all times), the user MUST send an empty &lt;default/&gt; element with no name.
</p>
<p>Example: Client declines the use of the default list:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='default2'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;default/>
  &lt;/query>
&lt;/iq>
        </pre>

<a name="rfc.section.10.6"></a><h4><a name="privacy-edit">10.6</a>&nbsp;Editing a Privacy List</h4>

<p>In order to edit a privacy list, the user MUST send an IQ stanza of type "set" with a &lt;query/&gt; element qualified by the 'jabber:iq:privacy' namespace that contains one &lt;list/&gt; child element possessing a 'name' attribute whose value is set to the list name the user would like to edit.  The &lt;list/&gt; element MUST contain one or more &lt;item/&gt; elements, which specify the user's desired changes to the list by including all elements in the list (not the "delta").
</p>
<p>Example: Client edits a privacy list:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='edit1'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='public'>
      &lt;item type='jid'
            value='tybalt@example.com'
            action='deny'
            order='3'/>
      &lt;item type='jid'
            value='paris@example.org'
            action='deny'
            order='5'/>
      &lt;item action='allow' order='68'/>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>Example: Server acknowledges success of list edit:
</p><pre>
&lt;iq type='result' id='edit1' to='juliet@example.com/balcony'/>
        </pre>

<p>Note: The value of the 'order' attribute for any given item is not fixed.  Thus in the foregoing example if the user would like to add 4 items between the "tybalt@example.com" item and the "paris@example.org" item, the user's client MUST renumber the relevant items before submitting the list to the server.
</p>
<a name="rfc.section.10.7"></a><h4><a name="privacy-add">10.7</a>&nbsp;Adding a New Privacy List</h4>

<p>The same protocol used to edit an existing list is used to create a new list.  If the list name matches that of an existing list, the request to add a new list will overwrite the old one.
</p>
<a name="rfc.section.10.8"></a><h4><a name="privacy-remove">10.8</a>&nbsp;Removing a Privacy List</h4>

<p>In order to remove a privacy list, the user MUST send an IQ stanza of type "set" with a &lt;query/&gt; element qualified by the 'jabber:iq:privacy' namespace that contains one empty &lt;list/&gt; child element possessing a 'name' attribute whose value is set to the list name the user would like to remove.
</p>
<p>Example: Client removes a privacy list:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='remove1'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='private'/>
  &lt;/query>
&lt;/iq>
        </pre>

<p>Example: Server acknowledges success of list removal:
</p><pre>
&lt;iq type='result' id='remove1' to='juliet@example.com/balcony'/>
        </pre>

<p>If a user attempts to remove an active list or the default list, the server MUST return a &lt;conflict/&gt; stanza error to the user.  The user MUST first set another list to active or default before removing it.
</p>
<p>If the user attempts to remove a list but a list by that name does not exist, the server MUST return an &lt;item-not-found/&gt; stanza error to the user:
</p>
<p>If the user attempts to remove more than one list in the same request, the server MUST return a &lt;bad request/&gt; stanza error to the user.
</p>
<a name="rfc.section.10.9"></a><h4><a name="privacy-message">10.9</a>&nbsp;Blocking Messages</h4>

<p>Server-side privacy lists enable a user to block incoming messages from other users based on the other user's JID, roster group, or subscription status (or globally).  The following examples illustrate the protocol.
</p>
<p>Example: User blocks based on JID:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='msg1'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='message-jid-example'>
      &lt;item type='jid'
            value='tybalt@example.com'
            action='deny'
            order='3'>
        &lt;message/>
      &lt;/item>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not receive messages from the user with the specified JID.
</p>
<p>Example: User blocks based on roster group:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='msg2'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='message-group-example'>
      &lt;item type='group'
            value='Enemies'
            action='deny'
            order='4'>
        &lt;message/>
      &lt;/item>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not receive messages from any users in the specified roster group.
</p>
<p>Example: User blocks based on subscription type:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='msg3'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='message-sub-example'>
      &lt;item type='subscription'
            value='none'
            action='deny'
            order='5'>
        &lt;message/>
      &lt;/item>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not receive messages from any users with the specified subscription type.
</p>
<p>Example: User blocks globally:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='msg4'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='message-global-example'>
      &lt;item action='deny' order='6'>
        &lt;message/>
      &lt;/item>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not receive messages from any other users.
</p>
<a name="rfc.section.10.10"></a><h4><a name="privacy-presencein">10.10</a>&nbsp;Blocking Inbound Presence Notifications</h4>

<p>Server-side privacy lists enable a user to block incoming presence notifications from other users based on the other user's JID, roster group, or subscription status (or globally).  The following examples illustrate the protocol.
</p>
<p>Note: presence notifications do not include presence subscriptions, only presence information that is broadcasted to the user because the user previously subscribed to a contact's presence information.  Thus this includes presence stanzas with no 'type' attribute or of type='unavailable' only.
</p>
<p>Example: User blocks based on JID:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='presin1'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='presin-jid-example'>
      &lt;item type='jid'
            value='tybalt@example.com'
            action='deny'
            order='7'>
        &lt;presence-in/>
      &lt;/item>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not receive presence notifications from the user with the specified JID.
</p>
<p>Example: User blocks based on roster group:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='presin2'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='presin-group-example'>
      &lt;item type='group'
            value='Enemies'
            action='deny'
            order='8'>
        &lt;presence-in/>
      &lt;/item>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not receive presence notifications from any users in the specified roster group.
</p>
<p>Example: User blocks based on subscription type:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='presin3'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='presin-sub-example'>
      &lt;item type='subscription'
            value='to'
            action='deny'
            order='9'>
        &lt;presence-in/>
      &lt;/item>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not receive presence notifications from any users with the specified subscription type.
</p>
<p>Example: User blocks globally:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='presin4'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='presin-global-example'>
      &lt;item action='deny' order='11'>
        &lt;presence-in/>
      &lt;/item>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not receive presence notifications from any other users.
</p>
<a name="rfc.section.10.11"></a><h4><a name="privacy-presenceout">10.11</a>&nbsp;Blocking Outbound Presence Notifications</h4>

<p>Server-side privacy lists enable a user to block outgoing presence notifications to other users based on the other user's JID, roster group, or subscription status (or globally).  The following examples illustrate the protocol.
</p>
<p>Note: presence notifications do not include presence subscriptions, only presence information that is broadcasted to contacts because those contacts previously subscribed to the user's presence information.  Thus this includes presence stanzas with no 'type' attribute or of type='unavailable' only.
</p>
<p>Example: User blocks based on JID:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='presout1'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='presout-jid-example'>
      &lt;item type='jid'
            value='tybalt@example.com'
            action='deny'
            order='13'>
        &lt;presence-out/>
      &lt;/item>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not send presence notifications to the user with the specified JID.
</p>
<p>Example: User blocks based on roster group:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='presout2'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='presout-group-example'>
      &lt;item type='group'
            value='Enemies'
            action='deny'
            order='15'>
        &lt;presence-out/>
      &lt;/item>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not send presence notifications to any users in the specified roster group.
</p>
<p>Example: User blocks based on subscription type:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='presout3'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='presout-sub-example'>
      &lt;item type='subscription'
            value='from'
            action='deny'
            order='17'>
        &lt;presence-out/>
      &lt;/item>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not send presence notifications to any users with the specified subscription type.
</p>
<p>Example: User blocks globally:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='presout4'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='presout-global-example'>
      &lt;item action='deny' order='23'>
        &lt;presence-out/>
      &lt;/item>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not send presence notifications to any other users.
</p>
<a name="rfc.section.10.12"></a><h4><a name="privacy-iq">10.12</a>&nbsp;Blocking IQs</h4>

<p>Server-side privacy lists enable a user to block incoming IQ stanzas from other users based on the other user's JID, roster group, or subscription status (or globally).  The following examples illustrate the protocol.
</p>
<p>Example: User blocks based on JID:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='iq1'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='iq-jid-example'>
      &lt;item type='jid'
            value='tybalt@example.com'
            action='deny'
            order='29'>
        &lt;iq/>
      &lt;/item>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not receive IQ stanzas from the user with the specified JID.
</p>
<p>Example: User blocks based on roster group:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='iq2'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='iq-group-example'>
      &lt;item type='group'
            value='Enemies'
            action='deny'
            order='31'>
        &lt;iq/>
      &lt;/item>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not receive IQ stanzas from any users in the specified roster group.
</p>
<p>Example: User blocks based on subscription type:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='iq3'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='iq-sub-example'>
      &lt;item type='subscription'
            value='none'
            action='deny'
            order='17'>
        &lt;iq/>
      &lt;/item>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not receive IQ stanzas from any users with the specified subscription type.
</p>
<p>Example: User blocks globally:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='iq4'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='iq-global-example'>
      &lt;item action='deny' order='1'>
        &lt;iq/>
      &lt;/item>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not receive IQ stanzas from any other users.
</p>
<a name="rfc.section.10.13"></a><h4><a name="privacy-all">10.13</a>&nbsp;Blocking All Communication</h4>

<p>Server-side privacy lists enable a user to block all stanzas from and to other users based on the other user's JID, roster group, or subscription status (or globally).  Note that this includes subscription-related presence stanzas, which are excluded by <a href="#privacy-presencein">Blocking Inbound Presence Notifications</a>.  The following examples illustrate the protocol.
</p>
<p>Example: User blocks based on JID:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='all1'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='all-jid-example'>
      &lt;item type='jid'
            value='tybalt@example.com'
            action='deny'
            order='23'/>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not receive any communications from, nor send any stanzas to, the user with the specified JID.
</p>
<p>Example: User blocks based on roster group:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='all2'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='all-group-example'>
      &lt;item type='group'
            value='Enemies'
            action='deny'
            order='13'/>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not receive any communications from, nor send any stanzas to, any users in the specified roster group.
</p>
<p>Example: User blocks based on subscription type:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='all3'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='all-sub-example'>
      &lt;item type='subscription'
            value='none'
            action='deny'
            order='11'/>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not receive any communications from, nor send any stanzas to, any users with the specified subscription type.
</p>
<p>Example: User blocks globally:
</p><pre>
&lt;iq from='romeo@example.org/orchard' type='set' id='all4'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='all-global-example'>
      &lt;item action='deny' order='7'/>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<p>As a result of creating and applying the foregoing list, the user will not receive any communications from, nor send any stanzas to, any other users.
</p>
<a name="rfc.section.10.14"></a><h4><a name="privacy-error">10.14</a>&nbsp;Blocked Entity Attempts to Communicate with User</h4>

<p>If a blocked entity attempts to send message or presence stanzas to the user, the user's server SHOULD silently drop the stanza and MUST NOT return an error to the sending entity.
</p>
<p>If a blocked entity attempts to send an IQ stanza of type "get" or "set" to the user, the user's server MUST return to the sending entity a &lt;feature-not-implemented/&gt; stanza error, since this is the standard error code sent from a client that does not understand the namespace of an IQ get or set.  IQ stanzas of other types SHOULD be silently dropped by the server.
</p>
<p>Example: Blocked entity attempts to send IQ get:
</p><pre>
&lt;iq type='get'
    to='romeo@example.net'
    from='tybalt@example.com/pda'
    id='probing1'>
  &lt;query xmlns='jabber:iq:version'/>
&lt;/iq>
        </pre>

<p>Example: Server returns error to blocked entity:
</p><pre>
&lt;iq type='error'
    from='romeo@example.net'
    to='tybalt@example.com/pda'
    id='probing1'>
  &lt;query xmlns='jabber:iq:version'/>
  &lt;error type='cancel'>
    &lt;feature-not-implemented
        xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>
  &lt;/error>
&lt;/iq>
        </pre>

<a name="rfc.section.10.15"></a><h4><a name="privacy-heuristics">10.15</a>&nbsp;Higher-Level Heuristics</h4>

<p>When building a representation of a higher-level privacy heuristic, a client SHOULD use the simplest possible representation.
</p>
<p>For example, the heuristic "block all communications with any user not in my roster" could be constructed in any of the following ways:
</p>
<p>
<ul class="text">
<li>allow communications from all JIDs in my roster (i.e., listing each JID as a separate list item), but block communications with everyone else
</li>
<li>allow communications from any user who is in one of the groups that make up my roster (i.e., listing each group as a separate list item), but block communications from everyone else
</li>
<li>allow communications from any user with whom I have a subscription of 'both' or 'to' or 'from' (i.e., listing each subscription value separately), but block communications from everyone else
</li>
<li>block communications from anyone whose subscription state is 'none'
</li>
</ul><p>
</p>
<p>The final representation is the simplest and SHOULD be used; here is the XML that would be sent in this case:
</p><pre>
&lt;iq type='set' id='heuristic1'>
  &lt;query xmlns='jabber:iq:privacy'>
    &lt;list name='heuristic-example'>
      &lt;item type='subscription'
            value='none'
            action='deny'
            order='437'/>
    &lt;/list>
  &lt;/query>
&lt;/iq>
        </pre>

<a name="rules"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;Server Rules for Handling XML Stanzas</h3>

<p>Basic routing and delivery rules for servers are defined in <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a>.  This section defines additional rules for XMPP-compliant instant messaging and presence servers.
</p>
<p>If the hostname of the domain identifier portion of the JID contained in the 'to' attribute of a stanza matches the hostname of the server itself and the JID contained in the 'to' attribute is of the form &lt;user@somedomain&gt; or &lt;user@somedomain/resource&gt;, the server MUST first apply any <a href="#privacy">privacy rules</a> that are in force.  If privacy rules allow the stanza, it SHOULD be routed or delivered to the intended recipient of the stanza as represented by the JID contained in the 'to' attribute.  The following additional rules apply to instant messaging and presence applications, over and above those defined in <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a>:
</p>
<p>
<ol class="text">
<li>If the JID is of the form &lt;user@domain/resource&gt; and an available resource matches the full JID, the recipient's server MUST deliver the stanza to that resource.
</li>
<li>If the JID is of the form &lt;user@domain/resource&gt; and no available resources match the full JID, the recipient's server (a) SHOULD silently ignore the stanza (i.e., neither deliver it nor return an error) if it is a presence stanza, (b) MUST return a &lt;service-unavailable/&gt; stanza error to the sender if it is an IQ stanza, and (c) MUST treat the stanza as if it were addressed to &lt;user@domain&gt; if it is a message stanza.
</li>
<li>If the JID is of the form &lt;user@somedomain&gt; and there is at least one available resource available for the user, the recipient's server MUST follow these rules:
      
<ol class="text">
<li>For message stanzas, the server SHOULD deliver the stanza to the highest-priority available resource (if the resource did not provide a value for the &lt;priority/&gt; element, the server SHOULD consider it to have provided a value of zero).  If two resources have the same priority, the server MAY use some other rule (e.g., most recent connect time, most recent activity time, or highest availability as determined by some hierarchy of &lt;show/&gt; values) to choose between them.  However, the server MUST NOT deliver the stanza to an available resource with a negative priority.
</li>
<li>For presence stanzas other than those of type "probe", the server MUST deliver the stanza to all available resources, except that the server MUST NOT deliver the stanza to an available resource that provided a negative value for the &lt;priority/&gt; element; for presence probes, the server SHOULD reply based on the rules defined in <a href="#presence-resp">Client and Server Presence Responsibilities</a>.
</li>
<li>For IQ stanzas, the server itself MUST reply on behalf of the user with either an IQ result or an IQ error, and MUST NOT deliver the IQ stanza to any of the available resources.  Specifically, if the semantics of the qualifying namespace define a reply that the server can provide, the server MUST reply to the stanza on behalf of the user; if not, the server MUST reply with a &lt;service-unavailable/&gt; stanza error.
</li>
</ol><p>
</li>
<li>If the JID is of the form &lt;user@somedomain&gt; and there are no available resources associated with the user, how the stanza is handled depends on the stanza type:
      
<ol class="text">
<li>For presence stanzas of type "subscribe", the server MUST maintain a record of the stanza and deliver it when the user next becomes available, as specified under <a href="#presence-resp">Client and Server Presence Responsibilities</a>.
</li>
<li>For all other presence stanzas, the server SHOULD silently ignore the stanza by not storing it for later delivery or replying to it on behalf of the user.
</li>
<li>For message stanzas, the server MAY choose to store the stanza on behalf of the user and deliver it when the user next becomes available.  However, if offline message storage is not enabled, the server MUST return to the sender a &lt;service-unavailable/&gt; stanza error.  (Note: offline message storage is not defined in XMPP since it strictly is a matter of implementation and service provisioning.)
</li>
<li>For IQ stanzas, the server itself MUST reply on behalf of the user with either an IQ result or an IQ error.  Specifically, if the semantics of the qualifying namespace define a reply that the server can provide, the server MUST reply to the stanza on behalf of the user; if not, the server MUST reply with a &lt;service-unavailable/&gt; stanza error.
</li>
</ol><p>
</li>
</ol><p>
</p>
<a name="compliance"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;IM and Presence Compliance Requirements</h3>

<p>This section summarizes the specific aspects of the Extensible Messaging and Presence Protocol that MUST be supported by instant messaging and presence servers and clients in order to be considered compliant implementations.  All such applications MUST comply with the requirements specified in <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a>.  The text in this section specifies additional compliance requirements for instant messaging and presence servers and clients; note well that the requirements described here supplement but do not supersede the core requirements.  Note also that a server or client may support only presence or instant messaging, and is not required to support both if only a presence service or an instant messaging service is desired.
</p>
<a name="rfc.section.12.1"></a><h4><a name="compliance-server">12.1</a>&nbsp;Servers</h4>

<p>In addition to core server compliance requirements, an instant messaging and presence server MUST additionally support the following protocols:
</p>
<p>
<ul class="text">
<li>All server-related instant messaging and presence syntax and semantics defined in this document, including presence broadcast on behalf of clients, presence subscriptions, roster storage and manipulation, privacy rules, and IM-specific routing and delivery rules
</li>
</ul><p>
</p>
<a name="rfc.section.12.2"></a><h4><a name="compliance-client">12.2</a>&nbsp;Clients</h4>

<p>In addition to core client compliance requirements, an instant messaging and presence client MUST additionally support the following protocols:
</p>
<p>
<ul class="text">
<li>Generation and handling of the IM-specific semantics of XML stanzas as defined by the XML schemas, including the 'type' attribute of message and presence stanzas as well as their child elements
</li>
<li>All client-related instant messaging syntax and semantics defined in this document, including presence subscriptions, roster management, and privacy rules
</li>
<li>End-to-end object encryption as defined in <a href="#XMPP-E2E" title="Saint-Andre, P., End-to-End Object Encryption in the Extensible Messaging and Presence Protocol (XMPP), August 2003.">XMPP e2e</a>[XMPP-E2E]
</li>
</ul><p>
</p>
<a name="i18n"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;Internationalization Considerations</h3>

<p>For internationalization considerations, refer to the relevant section of <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a>.
</p>
<a name="security"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.14"></a><h3>14.&nbsp;Security Considerations</h3>

<p>Core security considerations for XMPP are defined in the relevant section of <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a>.
</p>
<p>Additional considerations that apply only to instant messaging and presence applications of XMPP are defined in several places within this memo; specifically:
</p>
<p>
<ul class="text">
<li>When a server processes a stanza of any kind whose intended recipient is a user associated with one of the server's hostnames, the server MUST first apply any <a href="#privacy">privacy rules</a> that are in force (see <a href="#rules">Server Rules for Handling XML Stanzas</a>).
</li>
<li>When a server processes an inbound presence stanza of type "probe" whose intended recipient is a user associated with one of the server's hostnames, the server MUST NOT reveal the user's presence information if the sender is a user who is not authorized to receive that information as determined by presence subscriptions (see <a href="#presence-resp">Client and Server Presence Responsibilities</a>).
</li>
<li>When a server processes an outbound presence stanza with no type or of type "unavailable", it MUST follow the rules defined under <a href="#presence-resp">Client and Server Presence Responsibilities</a> in order to ensure that such presence information is not broadcasted to entities that are not authorized to know such information.
</li>
</ul><p>
</p>
<a name="ref"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.15"></a><h3>15.&nbsp;IANA Considerations</h3>

<p>For a number of related IANA considerations, refer to the relevant section of <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a>.
</p>
<a name="rfc.section.15.1"></a><h4><a name="iana-ns-session">15.1</a>&nbsp;XML Namespace Name for Session Data</h4>

<p>A URN sub-namespace for session-related data in the Extensible Messaging and Presence Protocol (XMPP) is defined as follows. (This namespace name adheres to the format defined in <a href="#XML-REG" title="Mealling, M., The IETF XML Registry, June 2003.">The IETF XML Registry</a>[XML-REG].)
</p>
<p>
<blockquote class="text"><dl>
<dt>URI:</dt>
<dd>urn:ietf:params:xml:ns:xmpp-session
</dd>
<dt>Specification:</dt>
<dd>XXXX
</dd>
<dt>Description:</dt>
<dd>This is the XML namespace name for session-related data in the Extensible Messaging and Presence Protocol (XMPP) as defined by XXXX.
</dd>
<dt>Registrant Contact:</dt>
<dd>IETF, XMPP Working Group, &lt;xmppwg@jabber.org&gt;
</dd>
</dl></blockquote><p>
</p>
<a name="rfc.section.15.2"></a><h4><a name="iana-reg-im">15.2</a>&nbsp;Instant Messaging SRV Protocol Label Registration</h4>

<p><a href="#IMP-SRV" title="Peterson, J., Address Resolution for Instant Messaging and Presence, October 2003.">Address Resolution for Instant Messaging and Presence</a>[IMP-SRV] defines an Instant Messaging SRV Protocol Label registry for protocols that can provide services that conform to the "_im" SRV Service label. Because XMPP is one such protocol, the IANA registers the "_xmpp" protocol label in the appropriate registry, as follows:
</p>
<p>
<blockquote class="text"><dl>
<dt>Protocol label:</dt>
<dd>_xmpp
</dd>
<dt>Specification:</dt>
<dd>XXXX
</dd>
<dt>Description:</dt>
<dd>Instant messaging protocol label for the Extensible Messaging and Presence Protocol (XMPP) as defined by XXXX.
</dd>
<dt>Registrant Contact:</dt>
<dd>IETF, XMPP Working Group, &lt;xmppwg@jabber.org&gt;
</dd>
</dl></blockquote><p>
</p>
<a name="rfc.section.15.3"></a><h4><a name="iana-reg-pres">15.3</a>&nbsp;Presence SRV Protocol Label Registration</h4>

<p><a href="#IMP-SRV" title="Peterson, J., Address Resolution for Instant Messaging and Presence, October 2003.">Address Resolution for Instant Messaging and Presence</a>[IMP-SRV] defines a Presence SRV Protocol Label registry for protocols that can provide services that conform to the "_pres" SRV Service label. Because XMPP is one such protocol, the IANA registers the "_xmpp" protocol label in the appropriate registry, as follows:
</p>
<p>
<blockquote class="text"><dl>
<dt>Protocol label:</dt>
<dd>_xmpp
</dd>
<dt>Specification:</dt>
<dd>XXXX
</dd>
<dt>Description:</dt>
<dd>Presence protocol label for the Extensible Messaging and Presence Protocol (XMPP) as defined by XXXX.
</dd>
<dt>Registrant Contact:</dt>
<dd>IETF, XMPP Working Group, &lt;xmppwg@jabber.org&gt;
</dd>
</dl></blockquote><p>
</p>
<a name="rfc.references3"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<h3>Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><b><a name="IMP-REQS">[IMP-REQS]</a></b></td>
<td class="author-text"><a href="mailto:mday@alum.mit.edu">Day, M.</a>, <a href="mailto:sonuag@microsoft.com">Aggarwal, S.</a> and <a href="mailto:jesse@intonet.com">J. Vincent</a>, "<a href="ftp://ftp.isi.edu/in-notes/rfc2779.txt">Instant Messaging / Presence Protocol Requirements</a>", RFC 2779, February 2000.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="IMP-SRV">[IMP-SRV]</a></b></td>
<td class="author-text">Peterson, J., "<a href="http://www.ietf.org/internet-drafts/draft-ietf-impp-srv-04.txt">Address Resolution for Instant Messaging and Presence</a>", draft-ietf-impp-srv-04 (work in progress), October 2003.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="TERMS">[TERMS]</a></b></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, "<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997 (<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><b><a name="XML">[XML]</a></b></td>
<td class="author-text"><a href="mailto:tbray@textuality.com">Bray, T.</a>, <a href="mailto:jeanpa@microsoft.com">Paoli, J.</a>, <a href="mailto:cmsmcq@uic.edu">Sperberg-McQueen, C.</a> and <a href="mailto:eve.maler@east.sun.com">E. Maler</a>, "<a href="http://www.w3.org/TR/REC-xml">Extensible Markup Language (XML) 1.0 (2nd ed)</a>", W3C REC-xml, October 2000.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="XML-NAMES">[XML-NAMES]</a></b></td>
<td class="author-text"><a href="mailto:tbray@textuality.com">Bray, T.</a>, <a href="mailto:dmh@corp.hp.com">Hollander, D.</a> and <a href="mailto:andrewl@microsoft.com">A. Layman</a>, "<a href="http://www.w3.org/TR/REC-xml-names">Namespaces in XML</a>", W3C REC-xml-names, January 1999.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="XMPP-CORE">[XMPP-CORE]</a></b></td>
<td class="author-text">Saint-Andre, P., "<a href="http://www.ietf.org/internet-drafts/draft-ietf-xmpp-core-20.txt">Extensible Messaging and Presence Protocol (XMPP): Core</a>", draft-ietf-xmpp-core-20 (work in progress), November 2003.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="XMPP-E2E">[XMPP-E2E]</a></b></td>
<td class="author-text">Saint-Andre, P., "<a href="http://www.ietf.org/internet-drafts/draft-ietf-xmpp-e2e-05.txt">End-to-End Object Encryption in the Extensible Messaging and Presence Protocol (XMPP)</a>", draft-ietf-xmpp-e2e-05 (work in progress), August 2003.</td></tr>
</table>

<a name="rfc.references4"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<h3>Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><b><a name="JSF">[JSF]</a></b></td>
<td class="author-text"><a href="mailto:info@jabber.org">Jabber Software Foundation</a>, "<a href="http://www.jabber.org/">Jabber Software Foundation</a>".</td></tr>
<tr><td class="author-text" valign="top"><b><a name="IMP-MODEL">[IMP-MODEL]</a></b></td>
<td class="author-text"><a href="mailto:mday@alum.mit.edu">Day, M.</a>, <a href="mailto:jdrosen@dynamicsoft.com">Rosenberg, J.</a> and <a href="mailto:suga@flab.fujitsu.co.jp">H. Sugano</a>, "<a href="ftp://ftp.isi.edu/in-notes/rfc2778.txt">A Model for Presence and Instant Messaging</a>", RFC 2778, February 2000.</td></tr>
<tr><td class="author-text" valign="top"><b><a name="VCARD">[VCARD]</a></b></td>
<td class="author-text"><a href="mailto:frank_dawson@lotus.com">Dawson, F.</a> and <a href="mailto:howes@netscape.com">T. Howes</a>, "<a href="ftp://ftp.isi.edu/in-notes/rfc2426.txt">vCard MIME Directory Profile</a>", RFC 2426, September 1998 (<a href="http://xml.resource.org/public/rfc/html/rfc2426.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2426.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><b><a name="XML-REG">[XML-REG]</a></b></td>
<td class="author-text">Mealling, M., "<a href="http://www.ietf.org/internet-drafts/draft-mealling-iana-xmlns-registry-05.txt">The IETF XML Registry</a>", draft-mealling-iana-xmlns-registry-05 (work in progress), June 2003.</td></tr>
</table>

<a name="rfc.authors"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Peter Saint-Andre</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Jabber Software Foundation</td></tr>
<tr><td class="author" align="right">EMail:&nbsp;</td>
<td class="author-text"><a href="mailto:stpeter@jabber.org">stpeter@jabber.org</a></td></tr>
</table>

<a name="vcard"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;vCards</h3>

<p>Sections 3.1.3 and 4.1.4 of <a href="#IMP-REQS" title="Day, M., Aggarwal, S. and J. Vincent, Instant Messaging / Presence Protocol Requirements, February 2000.">[IMP-REQS]</a> require that it be possible to retrieve out-of-band contact information for other users (e.g., telephone number or email address).  An XML representation of the vCard specification defined in <a href="#VCARD" title="Dawson, F. and T. Howes, vCard MIME Directory Profile, September 1998.">RFC 2426</a>[VCARD] is in common use within the Jabber community to provide such information but is out of scope for XMPP (documentation of this protocol is contained in "JEP-0054: vcard-temp", published by the <a href="#JSF" title="Jabber Software Foundation, Jabber Software Foundation, .">Jabber Software Foundation</a>[JSF]).
</p>
<a name="def"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.B"></a><h3>Appendix B.&nbsp;XML Schemas</h3>

<p>The following XML schemas are descriptive, not normative.  For schemas defining the core features of XMPP, refer to <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a>.
</p>
<a name="rfc.section.B.1"></a><h4><a name="def-client">B.1</a>&nbsp;jabber:client</h4>
<pre>
&lt;?xml version='1.0' encoding='UTF-8'?>

&lt;xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    xmlns:xml='http://www.w3.org/XML/1998/namespace'
    targetNamespace='jabber:client'
    xmlns='jabber:client'
    elementFormDefault='qualified'>

  &lt;xs:import namespace='http://www.w3.org/XML/1998/namespace'
             schemaLocation='http://www.w3.org/2001/xml.xsd'/>

  &lt;xs:element name='message'>
     &lt;xs:complexType>
        &lt;xs:sequence>
           &lt;xs:element ref='subject'
                       minOccurs='0'
                       maxOccurs='unbounded'/>
           &lt;xs:element ref='body'
                       minOccurs='0'
                       maxOccurs='unbounded'/>
           &lt;xs:element ref='thread'
                       minOccurs='0'
                       maxOccurs='1'/>
           &lt;xs:any     namespace='##other'
                       minOccurs='0'
                       maxOccurs='unbounded'/>
           &lt;xs:element ref='error'
                       minOccurs='0'
                       maxOccurs='1'/>
        &lt;/xs:sequence>
        &lt;xs:attribute name='to'
                      type='xs:string'
                      use='optional'/>
        &lt;xs:attribute name='from'
                      type='xs:string'
                      use='optional'/>
        &lt;xs:attribute name='id'
                      type='xs:NMTOKEN'
                      use='optional'/>
        &lt;xs:attribute ref='xml:lang' use='optional'/>
        &lt;xs:attribute name='type' use='optional'>
          &lt;xs:simpleType>
            &lt;xs:restriction base='xs:NCName'>
              &lt;xs:enumeration value='chat'/>
              &lt;xs:enumeration value='error'/>
              &lt;xs:enumeration value='groupchat'/>
              &lt;xs:enumeration value='headline'/>
              &lt;xs:enumeration value='normal'/>
            &lt;/xs:restriction>
          &lt;/xs:simpleType>
        &lt;/xs:attribute>
     &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='body' type='xs:string'>
    &lt;xs:complexType>
      &lt;xs:attribute ref='xml:lang' use='optional'/>
    &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='subject' type='xs:string'>
    &lt;xs:complexType>
      &lt;xs:attribute ref='xml:lang' use='optional'/>
    &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='thread' type='xs:NMTOKEN'/>

  &lt;xs:element name='presence'>
    &lt;xs:complexType>
      &lt;xs:sequence>
        &lt;xs:element ref='show'
                    minOccurs='0'
                    maxOccurs='1'/>
        &lt;xs:element ref='status'
                    minOccurs='0'
                    maxOccurs='unbounded'/>
        &lt;xs:element ref='priority'
                    minOccurs='0'
                    maxOccurs='1'/>
        &lt;xs:any     namespace='##other'
                    minOccurs='0'
                    maxOccurs='unbounded'/>
        &lt;xs:element ref='error'
                    minOccurs='0'
                    maxOccurs='1'/>
      &lt;/xs:sequence>
      &lt;xs:attribute name='to'
                    type='xs:string'
                    use='optional'/>
      &lt;xs:attribute name='from'
                    type='xs:string'
                    use='optional'/>
      &lt;xs:attribute name='id'
                    type='xs:NMTOKEN'
                    use='optional'/>
      &lt;xs:attribute ref='xml:lang' use='optional'/>
      &lt;xs:attribute name='type' use='optional'>
        &lt;xs:simpleType>
          &lt;xs:restriction base='xs:NCName'>
            &lt;xs:enumeration value='subscribe'/>
            &lt;xs:enumeration value='subscribed'/>
            &lt;xs:enumeration value='unsubscribe'/>
            &lt;xs:enumeration value='unsubscribed'/>
            &lt;xs:enumeration value='unavailable'/>
            &lt;xs:enumeration value='probe'/>
            &lt;xs:enumeration value='error'/>
          &lt;/xs:restriction>
        &lt;/xs:simpleType>
      &lt;/xs:attribute>
    &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='show'>
    &lt;xs:simpleType>
      &lt;xs:restriction base='xs:NCName'>
        &lt;xs:enumeration value='away'/>
        &lt;xs:enumeration value='chat'/>
        &lt;xs:enumeration value='dnd'/>
        &lt;xs:enumeration value='xa'/>
      &lt;/xs:restriction>
    &lt;/xs:simpleType>
  &lt;/xs:element>

  &lt;xs:element name='status' type='xs:string'>
    &lt;xs:complexType>
      &lt;xs:attribute ref='xml:lang' use='optional'/>
    &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='priority' type='xs:byte'/>

  &lt;xs:element name='iq'>
    &lt;xs:complexType>
      &lt;xs:sequence>
        &lt;xs:any     namespace='##other'
                    minOccurs='0'
                    maxOccurs='1'/>
        &lt;xs:element ref='error'
                    minOccurs='0'
                    maxOccurs='1'/>
      &lt;/xs:sequence>
      &lt;xs:attribute name='to'
                    type='xs:string'
                    use='optional'/>
      &lt;xs:attribute name='from'
                    type='xs:string'
                    use='optional'/>
      &lt;xs:attribute name='id'
                    type='xs:NMTOKEN'
                    use='required'/>
      &lt;xs:attribute ref='xml:lang' use='optional'/>
      &lt;xs:attribute name='type' use='required'>
        &lt;xs:simpleType>
          &lt;xs:restriction base='xs:NCName'>
            &lt;xs:enumeration value='get'/>
            &lt;xs:enumeration value='set'/>
            &lt;xs:enumeration value='result'/>
            &lt;xs:enumeration value='error'/>
          &lt;/xs:restriction>
        &lt;/xs:simpleType>
      &lt;/xs:attribute>
    &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='error'>
    &lt;xs:complexType>
      &lt;xs:sequence>
        &lt;xs:any namespace='urn:ietf:params:xml:ns:xmpp-stanzas'
                maxOccurs='1'/>
        &lt;text   namespace='urn:ietf:params:xml:ns:xmpp-stanzas'
                minOccurs='0'
                maxOccurs='1'/>
        &lt;xs:any
            namespace='##other'
            minOccurs='0'
            maxOccurs='1'/>
      &lt;/xs:sequence>
      &lt;xs:attribute name='type' use='required'/>
        &lt;xs:simpleType>
          &lt;xs:restriction base='xs:NCName'>
            &lt;xs:enumeration value='cancel'/>
            &lt;xs:enumeration value='continue'/>
            &lt;xs:enumeration value='modify'/>
            &lt;xs:enumeration value='auth'/>
            &lt;xs:enumeration value='wait'/>
          &lt;/xs:restriction>
        &lt;/xs:simpleType>
      &lt;/xs:attribute>
      &lt;xs:attribute name='code' type='xs:byte' use='optional'/>
    &lt;/xs:complexType>
  &lt;/xs:element>

&lt;/xs:schema>
          </pre>

<a name="rfc.section.B.2"></a><h4><a name="def-server">B.2</a>&nbsp;jabber:server</h4>
<pre>
&lt;?xml version='1.0' encoding='UTF-8'?>

&lt;xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    xmlns:xml='http://www.w3.org/XML/1998/namespace'
    targetNamespace='jabber:server'
    xmlns='jabber:server'
    elementFormDefault='qualified'>

  &lt;xs:import namespace='http://www.w3.org/XML/1998/namespace'
             schemaLocation='http://www.w3.org/2001/xml.xsd'/>

  &lt;xs:element name='message'>
     &lt;xs:complexType>
        &lt;xs:sequence>
           &lt;xs:element ref='subject'
                       minOccurs='0'
                       maxOccurs='unbounded'/>
           &lt;xs:element ref='body'
                       minOccurs='0'
                       maxOccurs='unbounded'/>
           &lt;xs:element ref='thread'
                       minOccurs='0'
                       maxOccurs='1'/>
           &lt;xs:any     namespace='##other'
                       minOccurs='0'
                       maxOccurs='unbounded'/>
           &lt;xs:element ref='error'
                       minOccurs='0'
                       maxOccurs='1'/>
        &lt;/xs:sequence>
        &lt;xs:attribute name='to'
                      type='xs:string'
                      use='required'/>
        &lt;xs:attribute name='from'
                      type='xs:string'
                      use='required'/>
        &lt;xs:attribute name='id'
                      type='xs:NMTOKEN'
                      use='optional'/>
        &lt;xs:attribute ref='xml:lang' use='optional'/>
        &lt;xs:attribute name='type' use='optional'>
          &lt;xs:simpleType>
            &lt;xs:restriction base='xs:NCName'>
              &lt;xs:enumeration value='chat'/>
              &lt;xs:enumeration value='error'/>
              &lt;xs:enumeration value='groupchat'/>
              &lt;xs:enumeration value='headline'/>
              &lt;xs:enumeration value='normal'/>
            &lt;/xs:restriction>
          &lt;/xs:simpleType>
        &lt;/xs:attribute>
     &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='body' type='xs:string'>
    &lt;xs:complexType>
      &lt;xs:attribute ref='xml:lang' use='optional'/>
    &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='subject' type='xs:string'>
    &lt;xs:complexType>
      &lt;xs:attribute ref='xml:lang' use='optional'/>
    &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='thread' type='xs:NMTOKEN'/>

  &lt;xs:element name='presence'>
    &lt;xs:complexType>
      &lt;xs:sequence>
        &lt;xs:element ref='show'
                    minOccurs='0'
                    maxOccurs='1'/>
        &lt;xs:element ref='status'
                    minOccurs='0'
                    maxOccurs='unbounded'/>
        &lt;xs:element ref='priority'
                    minOccurs='0'
                    maxOccurs='1'/>
        &lt;xs:any     namespace='##other'
                    minOccurs='0'
                    maxOccurs='unbounded'/>
        &lt;xs:element ref='error'
                    minOccurs='0'
                    maxOccurs='1'/>
      &lt;/xs:sequence>
      &lt;xs:attribute name='to'
                    type='xs:string'
                    use='required'/>
      &lt;xs:attribute name='from'
                    type='xs:string'
                    use='required'/>
      &lt;xs:attribute name='id'
                    type='xs:NMTOKEN'
                    use='optional'/>
      &lt;xs:attribute ref='xml:lang' use='optional'/>
      &lt;xs:attribute name='type' use='optional'>
        &lt;xs:simpleType>
          &lt;xs:restriction base='xs:NCName'>
            &lt;xs:enumeration value='subscribe'/>
            &lt;xs:enumeration value='subscribed'/>
            &lt;xs:enumeration value='unsubscribe'/>
            &lt;xs:enumeration value='unsubscribed'/>
            &lt;xs:enumeration value='unavailable'/>
            &lt;xs:enumeration value='probe'/>
            &lt;xs:enumeration value='error'/>
          &lt;/xs:restriction>
        &lt;/xs:simpleType>
      &lt;/xs:attribute>
    &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='show'>
    &lt;xs:simpleType>
      &lt;xs:restriction base='xs:NCName'>
        &lt;xs:enumeration value='away'/>
        &lt;xs:enumeration value='chat'/>
        &lt;xs:enumeration value='dnd'/>
        &lt;xs:enumeration value='xa'/>
      &lt;/xs:restriction>
    &lt;/xs:simpleType>
  &lt;/xs:element>

  &lt;xs:element name='status' type='xs:string'>
    &lt;xs:complexType>
      &lt;xs:attribute ref='xml:lang' use='optional'/>
    &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='priority' type='xs:byte'/>

  &lt;xs:element name='iq'>
    &lt;xs:complexType>
      &lt;xs:sequence>
        &lt;xs:any     namespace='##other'
                    minOccurs='0'
                    maxOccurs='1'/>
        &lt;xs:element ref='error'
                    minOccurs='0'
                    maxOccurs='1'/>
      &lt;/xs:sequence>
      &lt;xs:attribute name='to'
                    type='xs:string'
                    use='required'/>
      &lt;xs:attribute name='from'
                    type='xs:string'
                    use='required'/>
      &lt;xs:attribute name='id'
                    type='xs:NMTOKEN'
                    use='required'/>
      &lt;xs:attribute ref='xml:lang' use='optional'/>
      &lt;xs:attribute name='type' use='required'>
        &lt;xs:simpleType>
          &lt;xs:restriction base='xs:NCName'>
            &lt;xs:enumeration value='get'/>
            &lt;xs:enumeration value='set'/>
            &lt;xs:enumeration value='result'/>
            &lt;xs:enumeration value='error'/>
          &lt;/xs:restriction>
        &lt;/xs:simpleType>
      &lt;/xs:attribute>
    &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='error'>
    &lt;xs:complexType>
      &lt;xs:sequence>
        &lt;xs:any namespace='urn:ietf:params:xml:ns:xmpp-stanzas'
                maxOccurs='1'/>
        &lt;text   namespace='urn:ietf:params:xml:ns:xmpp-stanzas'
                minOccurs='0'
                maxOccurs='1'/>
        &lt;xs:any
            namespace='##other'
            minOccurs='0'
            maxOccurs='1'/>
      &lt;/xs:sequence>
      &lt;xs:attribute name='type' use='required'/>
        &lt;xs:simpleType>
          &lt;xs:restriction base='xs:NCName'>
            &lt;xs:enumeration value='cancel'/>
            &lt;xs:enumeration value='continue'/>
            &lt;xs:enumeration value='modify'/>
            &lt;xs:enumeration value='auth'/>
            &lt;xs:enumeration value='wait'/>
          &lt;/xs:restriction>
        &lt;/xs:simpleType>
      &lt;/xs:attribute>
      &lt;xs:attribute name='code' type='xs:byte' use='optional'/>
    &lt;/xs:complexType>
  &lt;/xs:element>

&lt;/xs:schema>
          </pre>

<a name="rfc.section.B.3"></a><h4><a name="def-session">B.3</a>&nbsp;session</h4>
<pre>
&lt;?xml version='1.0' encoding='UTF-8'?>
&lt;xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='urn:ietf:params:xml:ns:xmpp-session'
    xmlns='urn:ietf:params:xml:ns:xmpp-session'
    elementFormDefault='qualified'>

  &lt;xs:element name='session' type='empty'/>

  &lt;xs:simpleType name='empty'>
    &lt;xs:restriction base='xs:string'>
      &lt;xs:enumeration value=''/>
    &lt;/xs:restriction>
  &lt;/xs:simpleType>

&lt;/xs:schema>
          </pre>

<a name="rfc.section.B.4"></a><h4><a name="def-privacy">B.4</a>&nbsp;jabber:iq:privacy</h4>
<pre>
&lt;?xml version='1.0' encoding='UTF-8'?>
&lt;xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='jabber:iq:privacy'
    xmlns='jabber:iq:privacy'
    elementFormDefault='qualified'>

  &lt;xs:element name='query'>
    &lt;xs:complexType>
      &lt;xs:sequence>
        &lt;xs:element ref='active'
                    minOccurs='0'
                    maxOccurs='1'/>
        &lt;xs:element ref='default'
                    minOccurs='0'
                    maxOccurs='1'/>
        &lt;xs:element ref='list'
                    minOccurs='0'
                    maxOccurs='unbounded'/>
      &lt;/xs:sequence>
    &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='active'>
    &lt;xs:complexType>
      &lt;xs:attribute name='name'
                    type='xs:string'
                    use='optional'/>
    &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='default'>
    &lt;xs:complexType>
      &lt;xs:attribute name='name'
                    type='xs:string'
                    use='optional'/>
    &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='list'>
    &lt;xs:complexType>
      &lt;xs:sequence>
        &lt;xs:element ref='item'
                    minOccurs='0'
                    maxOccurs='unbounded'/>
      &lt;/xs:sequence>
      &lt;xs:attribute name='name'
                    type='xs:string'
                    use='required'/>
    &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='item'>
    &lt;xs:complexType>
      &lt;xs:sequence>
        &lt;xs:element ref='iq'
                    minOccurs='0'
                    maxOccurs='1'/>
        &lt;xs:element ref='message'
                    minOccurs='0'
                    maxOccurs='1'/>
        &lt;xs:element ref='presence-in'
                    minOccurs='0'
                    maxOccurs='1'/>
        &lt;xs:element ref='presence-out'
                    minOccurs='0'
                    maxOccurs='1'/>
      &lt;/xs:sequence>
      &lt;xs:attribute name='order'
                    type='xs:unsignedInt'
                    use='required'/>
      &lt;xs:attribute name='value'
                    type='xs:string'
                    use='optional'/>
      &lt;xs:attribute name='action' use='required'>
        &lt;xs:simpleType>
          &lt;xs:restriction base='xs:NCName'>
            &lt;xs:enumeration value='allow'/>
            &lt;xs:enumeration value='deny'/>
          &lt;/xs:restriction>
        &lt;/xs:simpleType>
      &lt;/xs:attribute>
      &lt;xs:attribute name='type' use='optional'>
        &lt;xs:simpleType>
          &lt;xs:restriction base='xs:NCName'>
            &lt;xs:enumeration value='group'/>
            &lt;xs:enumeration value='jid'/>
            &lt;xs:enumeration value='subscription'/>
          &lt;/xs:restriction>
        &lt;/xs:simpleType>
      &lt;/xs:attribute>
    &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='iq' type='empty'/>
  &lt;xs:element name='message' type='empty'/>
  &lt;xs:element name='presence-in' type='empty'/>
  &lt;xs:element name='presence-out' type='empty'/>

  &lt;xs:simpleType name='empty'>
    &lt;xs:restriction base='xs:string'>
      &lt;xs:enumeration value=''/>
    &lt;/xs:restriction>
  &lt;/xs:simpleType>

&lt;/xs:schema>
          </pre>

<a name="rfc.section.B.5"></a><h4><a name="def-roster">B.5</a>&nbsp;jabber:iq:roster</h4>
<pre>
&lt;?xml version='1.0' encoding='UTF-8'?>
&lt;xs:schema
    xmlns:xs='http://www.w3.org/2001/XMLSchema'
    targetNamespace='jabber:iq:roster'
    xmlns='jabber:iq:roster'
    elementFormDefault='qualified'>

  &lt;xs:element name='query'>
    &lt;xs:complexType>
      &lt;xs:sequence>
        &lt;xs:element ref='item'
                    minOccurs='0'
                    maxOccurs='unbounded'/>
      &lt;/xs:sequence>
    &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='item'>
    &lt;xs:complexType>
      &lt;xs:sequence>
        &lt;xs:element ref='group'
                    minOccurs='0'
                    maxOccurs='unbounded'/>
      &lt;/xs:sequence>
      &lt;xs:attribute name='jid' type='xs:string' use='required'/>
      &lt;xs:attribute name='name' type='xs:string' use='optional'/>
      &lt;xs:attribute name='subscription' use='optional'>
        &lt;xs:simpleType>
          &lt;xs:restriction base='xs:NCName'>
            &lt;xs:enumeration value='to'/>
            &lt;xs:enumeration value='from'/>
            &lt;xs:enumeration value='both'/>
            &lt;xs:enumeration value='none'/>
            &lt;xs:enumeration value='remove'/>
          &lt;/xs:restriction>
        &lt;/xs:simpleType>
      &lt;/xs:attribute>
      &lt;xs:attribute name='ask' use='optional'>
        &lt;xs:simpleType>
          &lt;xs:restriction base='xs:NCName'>
            &lt;xs:enumeration value='subscribe'/>
          &lt;/xs:restriction>
        &lt;/xs:simpleType>
      &lt;/xs:attribute>
    &lt;/xs:complexType>
  &lt;/xs:element>

  &lt;xs:element name='group' type='xs:string'/>

&lt;/xs:schema>
          </pre>

<a name="diffs"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.C"></a><h3>Appendix C.&nbsp;Differences Between Jabber IM/Presence and XMPP</h3>

<p>This section is non-normative.
</p>
<p>XMPP has been adapted from the protocols originally developed in the Jabber open-source community, which can be thought of as "XMPP 0.9".  Because there exists a large installed base of Jabber implementations and deployments, it may be helpful to specify the key differences between Jabber and XMPP in order to expedite and encourage upgrades of those implementations and deployments to XMPP.  This section summarizes the differences that relate specifically to instant messaging and presence applications, while the corresponding section of <a href="#XMPP-CORE" title="Saint-Andre, P., Extensible Messaging and Presence Protocol (XMPP): Core, November 2003.">[XMPP-CORE]</a> summarizes the differences that relate to all XMPP applications.
</p>
<a name="rfc.section.C.1"></a><h4><a name="diffs-session">C.1</a>&nbsp;Session Establishment</h4>

<p>The client-to-server authentication protocol developed in the Jabber community assumes that every client is an IM client and therefore initiates an IM session upon successful authentication and resource binding, which are performed simultaneously (documention of this protocol is contained in "JEP-0078: Non-SASL Authentication", published by the <a href="#JSF" title="Jabber Software Foundation, Jabber Software Foundation, .">Jabber Software Foundation</a>[JSF]).  XMPP maintains a stricter separation between core functionality and IM functionality; therefore, an IM session is not created until the client specifically requests one using the protocol defined under <a href="#session">Session Establishment</a>.
</p>
<a name="rfc.section.C.2"></a><h4><a name="diffs-privacy">C.2</a>&nbsp;Privacy Rules</h4>

<p>The Jabber community began to define a protocol for communications blocking (privacy rules) in late 2001, but that effort was deprecated once the XMPP Working Group was formed.  Therefore the protocol defined under <a href="#privacy">Blocking Communication</a> is the only such protocol defined for use in the Jabber community.
</p>
<a name="rev"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<a name="rfc.section.D"></a><h3>Appendix D.&nbsp;Revision History</h3>

<p>Note to RFC Editor: please remove this entire appendix, and the corresponding entries in the table of contents, prior to publication.
</p>
<a name="rfc.section.D.1"></a><h4><a name="rev-19">D.1</a>&nbsp;Changes from draft-ietf-xmpp-im-18</h4>

<p>
<ul class="text">
<li>Added presence type of "probe" to XML schema.
</li>
<li>Added error 'code' attribute to XML schema.
</li>
<li>Added protocol label registrations for "_im" and "_pres" service labels.
</li>
<li>Adjusted formatting to conform to RFC Editor requirements.
</li>
</ul><p>
</p>
<a name="rfc.section.D.2"></a><h4><a name="rev-18">D.2</a>&nbsp;Changes from draft-ietf-xmpp-im-17</h4>

<p>
<ul class="text">
<li>Added missing server handling rules for &lt;user@domain/resource&gt; cases.
</li>
<li>Further clarified privacy rules syntax by describing child elements of &lt;item/&gt;.
</li>
<li>Clarified several points related to session establishment.
</li>
<li>Checked all references.
</li>
<li>Completed a thorough proofreading and consistency check of the entire text.
</li>
</ul><p>
</p>
<a name="rfc.section.D.3"></a><h4><a name="rev-17">D.3</a>&nbsp;Changes from draft-ietf-xmpp-im-16</h4>

<p>
<ul class="text">
<li>Added sentence to make explicit that blocking all communication includes subscription-related presence stanzas.
</li>
<li>Added clause to make explicit that privacy rules must be applied before handling of subscription-related presence stanzas and corresponding generation of roster pushes.
</li>
<li>Added syntax and semantics section for the 'jabber:iq:roster' namespace.
</li>
<li>Removed content about 'jabber:iq:last' namespace.
</li>
<li>Added several internal references from the security considerations section to other sections of this document.
</li>
<li>Moved most delivery handling rules from XMPP IM to Extensible Messaging and Presence Protocol (XMPP): Core.
</li>
<li>Moved detailed stanza syntax descriptions from Extensible Messaging and Presence Protocol (XMPP): Core to XMPP IM.
</li>
<li>Moved stanza schemas from Extensible Messaging and Presence Protocol (XMPP): Core to XMPP IM.
</li>
</ul><p>
</p>
<a name="rfc.section.D.4"></a><h4><a name="rev-16">D.4</a>&nbsp;Changes from draft-ietf-xmpp-im-15</h4>

<p>
<ul class="text">
<li>Specified stream error to be sent to active session if there is a conflict regarding session creation.
</li>
<li>Fixed several more typographical errors in the privacy rules examples.
</li>
<li>Corrected an error regarding server handling of IQ stanzas sent to bare JIDs.
</li>
<li>Added section on compliance requirements for instant messaging server and client implementations.
</li>
<li>Added non-normative section on differences between Jabber usage and XMPP specifications.
</li>
</ul><p>
</p>
<a name="rfc.section.D.5"></a><h4><a name="rev-15">D.5</a>&nbsp;Changes from draft-ietf-xmpp-im-14</h4>

<p>
<ul class="text">
<li>Added subscription state charts.
</li>
<li>Fixed several typographical errors in the privacy rules examples.
</li>
<li>Changed datatype of 'order' attribute in privacy rules from nonNegativeInteger to unsignedInt.
</li>
</ul><p>
</p>
<a name="rfc.section.D.6"></a><h4><a name="rev-14">D.6</a>&nbsp;Changes from draft-ietf-xmpp-im-13</h4>

<p>
<ul class="text">
<li>Made one small change to privacy list syntax rules.
</li>
</ul><p>
</p>
<a name="rfc.section.D.7"></a><h4><a name="rev-13">D.7</a>&nbsp;Changes from draft-ietf-xmpp-im-12</h4>

<p>
<ul class="text">
<li>Clarified meaning of the default message type as well as handling of unknown or unsupported types.
</li>
<li>Made several small editorial changes.
</li>
</ul><p>
</p>
<a name="rfc.section.D.8"></a><h4><a name="rev-12">D.8</a>&nbsp;Changes from draft-ietf-xmpp-im-11</h4>

<p>
<ul class="text">
<li>Further clarified subscription syntax and semantics.
</li>
<li>Further clarified presence responsibilities for clients and servers.
</li>
<li>Added 'xml:lang' example to presence status.
</li>
<li>Added subsection on presence priority.
</li>
<li>Defined server handling of unsolicited presence stanzas of type "subscribed".
</li>
<li>Specified default resource priority if not provided.
</li>
<li>Corrected several errors in the schemas.
</li>
<li>Added privacy list business rule regarding roster changes.
</li>
<li>Removed the 'jabber:iq:privacy:error' namespace (not necessary).
</li>
<li>Documented message type='normal'.
</li>
<li>Made numerous small editorial changes throughout.
</li>
</ul><p>
</p>
<a name="rfc.section.D.9"></a><h4><a name="rev-11">D.9</a>&nbsp;Changes from draft-ietf-xmpp-im-10</h4>

<p>
<ul class="text">
<li>Clarified presence responsibilities for servers and clients.
</li>
<li>Clarified the routing and delivery rules for servers.
</li>
<li>Made the 'xml:lang' examples more complete.
</li>
<li>Corrected several errors in the unsubscribe workflow.
</li>
<li>Made small editorial changes in several sections.
</li>
</ul><p>
</p>
<a name="rfc.section.D.10"></a><h4><a name="rev-10">D.10</a>&nbsp;Changes from draft-ietf-xmpp-im-09</h4>

<p>
<ul class="text">
<li>Clarified rules regarding allowable JID types in rosters.
</li>
<li>Further clarified the semantics and routing implications of presence priorities.
</li>
<li>Removed several obsolete subsections.
</li>
</ul><p>
</p>
<a name="rfc.section.D.11"></a><h4><a name="rev-09">D.11</a>&nbsp;Changes from draft-ietf-xmpp-im-08</h4>

<p>
<ul class="text">
<li>Removed authorization content (now addressed in Extensible Messaging and Presence Protocol (XMPP): Core).
</li>
<li>Added protocol for initiating an IM session, including schema and IANA registration template.
</li>
<li>Corrected &lt;*-condition/&gt; elements to be &lt;condition/&gt;.
</li>
<li>Made small editorial changes to address RFC Editor requirements.
</li>
</ul><p>
</p>
<a name="rfc.section.D.12"></a><h4><a name="rev-08">D.12</a>&nbsp;Changes from draft-ietf-xmpp-im-07</h4>

<p>
<ul class="text">
<li>Added several error cases for resource authorization and updated relevant schema.
</li>
</ul><p>
</p>
<a name="rfc.section.D.13"></a><h4><a name="rev-07">D.13</a>&nbsp;Changes from draft-ietf-xmpp-im-06</h4>

<p>
<ul class="text">
<li>Specified that IQ result stanzas are required in response to roster pushes.
</li>
<li>Changed stanza error namespace names to conform to the format defined in "The IETF XML Registry" as specified in Extensible Messaging and Presence Protocol (XMPP): Core.
</li>
<li>Removed note to RFC Editor regarding provisional namespace names.
</li>
</ul><p>
</p>
<a name="rfc.section.D.14"></a><h4><a name="rev-06">D.14</a>&nbsp;Changes from draft-ietf-xmpp-im-05</h4>

<p>
<ul class="text">
<li>Removed use of ask='unsubscribe' per list discussion.
</li>
<li>Clarified handling of resource conflict during authorization.
</li>
<li>Added schemas for jabber:iq:auth, jabber:iq:auth:error, and jabber:iq:privacy:error.
</li>
<li>Corrected several small protocol errors in the examples.
</li>
<li>Clarified semantics of message types.
</li>
</ul><p>
</p>
<a name="rfc.section.D.15"></a><h4><a name="rev-05">D.15</a>&nbsp;Changes from draft-ietf-xmpp-im-04</h4>

<p>
<ul class="text">
<li>Specified sending of unavailable presence after unsubscribe and subscription-cancellation actions.
</li>
<li>Further specified syntax and business rules for privacy lists.
</li>
<li>Brought error codes into line with definitions in draft-ietf-xmpp-core.
</li>
<li>Added note to RFC Editor regarding provisional namespace names.
</li>
<li>Removed vCard content and DTD, instead pointing to JSF documentation.
</li>
</ul><p>
</p>
<a name="rfc.section.D.16"></a><h4><a name="rev-04">D.16</a>&nbsp;Changes from draft-ietf-xmpp-im-03</h4>

<p>
<ul class="text">
<li>Fixed order processing on privacy rules per list discussion.
</li>
<li>Made numerous small editorial changes.
</li>
</ul><p>
</p>
<a name="rfc.section.D.17"></a><h4><a name="rev-03">D.17</a>&nbsp;Changes from draft-ietf-xmpp-im-02</h4>

<p>
<ul class="text">
<li>Added a great deal more detail to the narrative regarding server-side privacy rules as well as the interaction between rosters and subscriptions.
</li>
<li>Removed DTDs in favor of schemas (with the exception of vCard XML).
</li>
<li>Removed non-normative documentation of authentication using jabber:iq:auth and of in-band registration using jabber:iq:register, since these are maintained by the Jabber Software Foundation and are not part of the XMPP specification.
</li>
</ul><p>
</p>
<a name="rfc.section.D.18"></a><h4><a name="rev-02">D.18</a>&nbsp;Changes from draft-ietf-xmpp-im-01</h4>

<p>
<ul class="text">
<li>Made numerous small editorial changes.
</li>
</ul><p>
</p>
<a name="rfc.section.D.19"></a><h4><a name="rev-01">D.19</a>&nbsp;Changes from draft-ietf-xmpp-im-00</h4>

<p>
<ul class="text">
<li>Moved registration and authentication via jabber:iq:auth to non-normative appendices.
</li>
<li>Changed initial presence stanza from MUST be empty to SHOULD be empty.
</li>
<li>Specified that user or clients should not send presence stanzas of type='probe'.
</li>
<li>Specified the algorithm for digest passwords.
</li>
</ul><p>
</p>
<a name="rfc.section.D.20"></a><h4><a name="rev-00">D.20</a>&nbsp;Changes from draft-miller-xmpp-im-02</h4>

<p>
<ul class="text">
<li>Added information about the 'jabber:iq:last' protocol to meet the requirement defined in section 3.2.4 of RFC 2779.
</li>
<li>Added information about the 'jabber:iq:privacy' protocol to meet the requirement defined in section 2.3.5 of RFC 2779.
</li>
<li>Added information about the vCard XML protocol to meet the requirement defined in sections 3.1.3 and 4.1.4 of RFC 2779.
</li>
<li>Changed the material describing authentication (but not resource authorization) with 'jabber:iq:auth' to non-normative.
</li>
<li>Noted that the only watchers are subscribers.
</li>
<li>Nomenclature changes: (1) from "chunks" to "stanzas"; (2) from "host" to "server"; (3) from "node" to "client" or "user" (as appropriate).
</li>
</ul><p>
</p><a name="rfc.copyright"><br><hr size="1" shade="0"></a>
<table border="0" cellpadding="0" cellspacing="2" width="30" height="15" align="right"><tr><td bgcolor="#990000" align="center" width="30" height="15"><a href="#toc" CLASS="link2"><font face="monaco, MS Sans Serif" color="#ffffff" size="1"><b>&nbsp;TOC&nbsp;</b></font></a><br></td></tr></table>
<h3>Intellectual Property Statement</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of
any intellectual property or other rights that might be claimed
to  pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; neither does
it represent that it has made any effort to identify any such
rights. Information on the IETF's procedures with respect to
rights in standards-track and standards-related documentation
can be found in BCP-11. Copies of claims of rights made
available for publication and any assurances of licenses to
be made available, or the result of an attempt made
to obtain a general license or permission for the use of such
proprietary rights by implementors or users of this
specification can be obtained from the IETF Secretariat.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its
attention any copyrights, patents or patent applications, or
other proprietary rights which may cover technology that may be
required to practice this standard. Please address the
information to the IETF Executive Director.</p>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright (C) The Internet Society (2003). All Rights Reserved.</p>
<p class='copyright'>
This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it
or assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are
included on all such copies and derivative works. However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to the Internet Society or other
Internet organizations, except as needed for the purpose of
developing Internet standards in which case the procedures for
copyrights defined in the Internet Standards process must be
followed, or as required to translate it into languages other than
English.</p>
<p class='copyright'>
The limited permissions granted above are perpetual and will not be
revoked by the Internet Society or its successors or assignees.</p>
<p class='copyright'>
This document and the information contained herein is provided on an
&quot;AS IS&quot; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.</p>
<h3>Acknowledgment</h3>
<p class='copyright'>
Funding for the RFC Editor function is currently provided by the
Internet Society.</p>
</font></body></html>
